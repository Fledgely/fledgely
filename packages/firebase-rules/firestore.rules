rules_version = '2';

/**
 * Fledgely Firestore Security Rules
 *
 * Story 8.1: Family Data Isolation Rules
 *
 * SECURITY ARCHITECTURE (SA1):
 * These rules are the PRIMARY security boundary for Fledgely.
 * All rules changes require PR review and automated testing.
 *
 * SECURITY PRINCIPLES:
 * 1. Deny by default - All paths blocked unless explicitly allowed
 * 2. Least privilege - Minimum permissions required for operation
 * 3. User isolation - Users can only access their own data
 * 4. Family isolation - No data leakage across families (NFR14)
 * 5. Guardian-based access - Children accessed only by their guardians
 * 6. Data symmetry - Co-parents have identical access (Epic 3A)
 *
 * SECURITY MONITORING:
 * - All rule violations are logged to Cloud Logging by default
 * - View logs: GCP Console > Logging > Logs Explorer
 * - Filter: resource.type="firestore.googleapis.com/rules"
 * - Set up alerts for unusual patterns (repeated denials, ID guessing attempts)
 *
 * ADVERSARIAL PROTECTIONS (NFR85):
 * - ID guessing: Random familyId/childId returns empty, not error
 * - Path traversal: Nested paths validated at each level
 * - Token manipulation: Auth token verified against actual user
 * - Cross-family queries: Filtered server-side, never exposed
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // User profiles: users can only read/write their own document
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Family documents: only guardians can access their family
    match /families/{familyId} {
      // Helper function to check if user is a guardian of this family
      function isGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardians[].uid;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardians[].uid;
      }

      // Read: only guardians can read family data
      allow read: if isGuardian();

      // Create: authenticated user can create family if they're adding themselves as guardian
      allow create: if request.auth != null && isCreatingAsGuardian();

      // Update: only existing guardians can update family
      // Story 3.4 AC6: Prevent guardian removal in co-managed families
      // Guardians array can only grow or stay same size - no removals allowed
      allow update: if isGuardian() &&
        request.resource.data.guardians.size() >= resource.data.guardians.size();

      // Delete: only guardians can delete their family (single-guardian only)
      // Multi-guardian families require support intervention
      allow delete: if isGuardian() && resource.data.guardians.size() == 1;

      // =============================================================
      // FAMILY SUBCOLLECTIONS - Story 12: Device Enrollment
      // =============================================================

      // Devices subcollection: enrolled devices for this family
      //
      // Story 12.4: Device Registration in Firestore
      // Guardians can view family devices.
      // Creation/updates are done via Cloud Functions for security.
      //
      match /devices/{deviceId} {
        // Helper: Check if user is a guardian of the parent family document
        function isFamilyDeviceGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardians[].uid;
        }

        // Read: Guardians can view enrolled devices
        allow read: if isFamilyDeviceGuardian();

        // Create: Only Cloud Functions can create (via Admin SDK)
        // Direct client creation is denied for security
        allow create: if false;

        // Update: Guardians can update device settings (name, childId)
        allow update: if isFamilyDeviceGuardian();

        // Delete: Guardians can unenroll devices
        allow delete: if isFamilyDeviceGuardian();
      }

      // Enrollment tokens subcollection: QR code tokens for device enrollment
      //
      // Story 12.1: Enrollment QR Code Generation
      // Guardians can create and view tokens.
      //
      match /enrollmentTokens/{tokenId} {
        function isEnrollmentTokenGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardians[].uid;
        }

        // Read: Guardians can view their tokens
        allow read: if isEnrollmentTokenGuardian();

        // Create: Guardians can create enrollment tokens
        allow create: if isEnrollmentTokenGuardian();

        // Update: Guardians can update token status
        allow update: if isEnrollmentTokenGuardian();

        // Delete: Guardians can delete tokens
        allow delete: if isEnrollmentTokenGuardian();
      }

      // Enrollment requests subcollection: pending device enrollment requests
      //
      // Story 12.3: Device-to-Device Enrollment Approval
      // Guardians can view and manage enrollment requests.
      // Creation is done via Cloud Functions (from extension).
      //
      match /enrollmentRequests/{requestId} {
        function isEnrollmentRequestGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardians[].uid;
        }

        // Read: Guardians can view enrollment requests
        allow read: if isEnrollmentRequestGuardian();

        // Create: Only Cloud Functions can create (from extension)
        allow create: if false;

        // Update: Guardians can approve/reject requests
        allow update: if isEnrollmentRequestGuardian();

        // Delete: Not allowed (keep audit trail)
        allow delete: if false;
      }
    }

    // Child documents: guardians can access children in their family
    //
    // EPIC 3A DATA SYMMETRY PRINCIPLE (Story 3A.1):
    // Both co-parents in shared custody families MUST have IDENTICAL access.
    // All guardians in the guardians[] array have equal read permissions.
    // No data filtering, delay, or modification based on which guardian views.
    // This prevents information asymmetry in custody situations.
    //
    // STORY 8.1 FAMILY DATA ISOLATION:
    // - Children are only accessible by their guardians
    // - Cross-family access is impossible via these rules
    // - ID guessing returns no data (not errors)
    //
    match /children/{childId} {
      // Helper function to check if user is a guardian of this child
      // DATA SYMMETRY: All guardians in guardians[] have identical access
      function isChildGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardians[].uid;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardians[].uid;
      }

      // Helper function to verify user is guardian of the family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth.uid in family.data.guardians[].uid;
      }

      // Read: only child guardians can read
      // DATA SYMMETRY: Both co-parents see identical data simultaneously
      // ISOLATION: Cross-family/cross-child access denied
      allow read: if isChildGuardian();

      // Create: authenticated user who is guardian of the family
      allow create: if request.auth != null &&
        isCreatingAsGuardian() && isFamilyGuardian();

      // Update: only existing guardians can update
      allow update: if isChildGuardian();

      // Delete: only existing guardians can delete
      allow delete: if isChildGuardian();

      // =============================================================
      // CHILD SUBCOLLECTIONS - Story 8.1 Family Data Isolation
      // =============================================================
      // All child subcollections inherit guardian-based access.
      // This ensures complete data isolation at the child level.

      // Screenshots subcollection: child's captured screenshots
      //
      // SECURITY: Screenshot data is the most sensitive data in fledgely.
      // Only guardians of the specific child can access.
      // Siblings cannot see each other's screenshots (Story 8.2).
      //
      match /screenshots/{screenshotId} {
        // Helper: Check if user is guardian of the parent child document
        function isScreenshotChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardians[].uid;
        }

        // Read: Only child's guardians can view screenshots
        // DATA SYMMETRY: Both co-parents see same screenshots
        allow read: if isScreenshotChildGuardian();

        // Create: Only authenticated devices can upload (via Cloud Functions)
        // Direct client upload is denied - must go through validated API
        allow create: if false;

        // Update: Not allowed - screenshots are immutable
        allow update: if false;

        // Delete: Only guardians can delete (for retention policy)
        allow delete: if isScreenshotChildGuardian();
      }

      // Activity subcollection: child's activity logs
      //
      // SECURITY: Activity data includes browsing and app usage.
      // Only guardians of the specific child can access.
      //
      match /activity/{activityId} {
        // Helper: Check if user is guardian of the parent child document
        function isActivityChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardians[].uid;
        }

        // Read: Only child's guardians can view activity
        allow read: if isActivityChildGuardian();

        // Create: Only devices can create (via Cloud Functions)
        allow create: if false;

        // Update: Not allowed - activity logs are append-only
        allow update: if false;

        // Delete: Only guardians can delete (for retention policy)
        allow delete: if isActivityChildGuardian();
      }

      // Agreements subcollection: child's agreement documents
      //
      // Story 5-6: Agreement creation, signing, activation
      // Both guardians and the child can read their agreement.
      // Modifications follow approval workflow.
      //
      match /agreements/{agreementId} {
        // Helper: Check if user is guardian of the parent child document
        function isAgreementChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardians[].uid;
        }

        // Read: Guardians and the child themselves can read
        // Note: Child auth is implemented in later epics
        allow read: if isAgreementChildGuardian();

        // Create: Guardians can create agreements
        allow create: if isAgreementChildGuardian();

        // Update: Guardians can update (versioning managed by app logic)
        allow update: if isAgreementChildGuardian();

        // Delete: Not allowed - agreements have history
        allow delete: if false;
      }

      // Flags subcollection: AI-generated flags for concerning content
      //
      // Story 21-22: Concerning content detection and review
      // Guardians can view and resolve flags.
      //
      match /flags/{flagId} {
        // Helper: Check if user is guardian of the parent child document
        function isFlagChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardians[].uid;
        }

        // Read: Only child's guardians can view flags
        allow read: if isFlagChildGuardian();

        // Create: Only Cloud Functions (AI service) can create
        allow create: if false;

        // Update: Guardians can update (resolve, add notes)
        allow update: if isFlagChildGuardian();

        // Delete: Not allowed - flags are audit trail
        allow delete: if false;
      }

      // Devices subcollection: enrolled devices for this child
      //
      // Story 9-17: Device enrollment and monitoring
      // Guardians can view and manage enrolled devices.
      //
      match /devices/{deviceId} {
        // Helper: Check if user is guardian of the parent child document
        function isDeviceChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardians[].uid;
        }

        // Read: Guardians can view enrolled devices
        allow read: if isDeviceChildGuardian();

        // Create: Guardians can enroll devices
        allow create: if isDeviceChildGuardian();

        // Update: Guardians can update device settings
        allow update: if isDeviceChildGuardian();

        // Delete: Guardians can unenroll devices
        allow delete: if isDeviceChildGuardian();
      }
    }

    // Invitation documents: for co-parent invitations
    match /invitations/{invitationId} {
      // Helper to check if user is the inviter
      function isInviter() {
        return request.auth != null &&
          request.auth.uid == resource.data.inviterUid;
      }

      // Helper to check if user is a guardian of the invitation's family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Read: Allow public read for pending invitations (Story 3.3 - AC1)
      // This allows invitees to see invitation details BEFORE signing in.
      // Security: Token is unguessable UUID, and only pending invitations are readable.
      // Authenticated users can read any invitation (for guardians managing invitations).
      allow read: if resource.data.status == 'pending' || request.auth != null;

      // Create: authenticated users can create if they're set as inviter
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.inviterUid;

      // Update: only inviter can update (for revoking, marking expired)
      allow update: if isInviter();

      // Delete: not allowed (use status: revoked instead)
      allow delete: if false;
    }

    // Audit logs: append-only logs for data viewing transparency
    //
    // Story 3A.1: Data Symmetry Enforcement - AC3
    // Records when guardians view child or family data.
    // Story 3A.5: Screenshot Viewing Rate Alert uses this data.
    // Story 12.5: Device assignment audit logs (AC4) - created via Admin SDK (Cloud Functions)
    //
    // AC5 (Future): Access Revocation Symmetry
    // When one parent's access is revoked (Story 3.6 legal petition),
    // audit logs may become inaccessible to both until resolved.
    // This ensures no information asymmetry during dispute resolution.
    //
    match /auditLogs/{logId} {
      // Helper: Check if user is a guardian of the family in the audit log
      function isFamilyGuardianForAudit() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Helper: Check if user is guardian of family for existing audit log
      function canReadFamilyAudit() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Read: Family guardians can read audit logs for their family
      // DATA SYMMETRY: Both co-parents can see all viewing activity
      allow read: if canReadFamilyAudit();

      // Create: Guardians can only log their own views (prevent spoofing)
      // Note: Server-side audit logs (device assignment) use Admin SDK and bypass rules
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.viewerUid &&
        isFamilyGuardianForAudit();

      // Update/Delete: Not allowed (audit trail immutability)
      // Audit logs are append-only for compliance and trust
      allow update, delete: if false;
    }

    // Safety setting change proposals: two-parent approval workflow
    //
    // Story 3A.2: Safety Settings Two-Parent Approval
    // Story 3A.4: Safety Rule 48-Hour Cooling Period
    //
    // In shared custody families, safety-related setting changes require
    // both guardians to approve before taking effect.
    //
    // Key rules:
    // - Only guardians can propose changes for their family
    // - Only the OTHER guardian (not the proposer) can approve/decline
    // - Proposals cannot be self-approved (prevents single-parent override)
    // - Approved/declined/expired changes are immutable (audit trail)
    // - Story 3A.4: Protection reductions enter 48-hour cooling period
    // - Story 3A.4: Either guardian can cancel during cooling period
    //
    match /safetySettingChanges/{changeId} {
      // Helper: Check if user is a guardian of the family for new proposals
      function isFamilyGuardianForCreate() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Helper: Check if user is a guardian of the family for existing changes
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Helper: Check if user is the OTHER guardian (not the proposer)
      // CRITICAL: This prevents self-approval
      function isOtherGuardian() {
        return isFamilyGuardian() &&
          request.auth.uid != resource.data.proposedByUid;
      }

      // Read: Family guardians can read all proposals for their family
      // DATA SYMMETRY: Both co-parents see all pending, approved, and declined changes
      allow read: if isFamilyGuardian();

      // Create: Guardians can propose changes for their family
      // Must set themselves as proposer (prevent impersonation)
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.proposedByUid &&
        isFamilyGuardianForCreate() &&
        request.resource.data.status == 'pending_approval';

      // Update for approval/decline: Only the OTHER guardian can approve/decline
      // - Must be pending_approval to be updated
      // - Story 3A.4: Can transition to approved, declined, OR cooling_period
      // - Cannot transition directly to 'activated' (must go through cooling period)
      // - Cannot modify proposal details, only status and resolution fields
      allow update: if isOtherGuardian() &&
        resource.data.status == 'pending_approval' &&
        request.resource.data.status in ['approved', 'declined', 'cooling_period'] &&
        // Preserve original proposal data (immutability of proposal content)
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.settingType == resource.data.settingType &&
        request.resource.data.currentValue == resource.data.currentValue &&
        request.resource.data.proposedValue == resource.data.proposedValue &&
        request.resource.data.proposedByUid == resource.data.proposedByUid;

      // Story 3A.4: Update for cancellation during cooling period
      // - Either guardian (proposer OR approver) can cancel during cooling period
      // - Must be in cooling_period status
      // - Can only transition to 'cancelled'
      // - Must preserve proposal data immutability
      allow update: if isFamilyGuardian() &&
        resource.data.status == 'cooling_period' &&
        request.resource.data.status == 'cancelled' &&
        // Preserve original proposal data
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.settingType == resource.data.settingType &&
        request.resource.data.currentValue == resource.data.currentValue &&
        request.resource.data.proposedValue == resource.data.proposedValue &&
        request.resource.data.proposedByUid == resource.data.proposedByUid;

      // Delete: Not allowed (keep audit trail)
      // Expired proposals remain for historical reference
      allow delete: if false;
    }

    // Agreement Templates: public read for authenticated users
    //
    // Story 4.1: Template Library Structure - AC7
    //
    // Templates are shared resources that all authenticated users can browse.
    // They provide starting points for family agreements.
    //
    // Key rules:
    // - Any authenticated user can read templates
    // - Write access is denied (templates are managed via admin tools/deployment)
    // - No user-generated content in templates (prevents abuse)
    //
    match /agreementTemplates/{templateId} {
      // Read: Any authenticated user can browse templates
      allow read: if request.auth != null;

      // Write: Not allowed through client SDK
      // Templates are seeded/managed through admin tools or CI/CD
      allow write: if false;
    }

    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
