rules_version = '2';

/**
 * Fledgely Firestore Security Rules
 *
 * Story 8.1: Family Data Isolation Rules
 *
 * SECURITY ARCHITECTURE (SA1):
 * These rules are the PRIMARY security boundary for Fledgely.
 * All rules changes require PR review and automated testing.
 *
 * SECURITY PRINCIPLES:
 * 1. Deny by default - All paths blocked unless explicitly allowed
 * 2. Least privilege - Minimum permissions required for operation
 * 3. User isolation - Users can only access their own data
 * 4. Family isolation - No data leakage across families (NFR14)
 * 5. Guardian-based access - Children accessed only by their guardians
 * 6. Data symmetry - Co-parents have identical access (Epic 3A)
 *
 * SECURITY MONITORING:
 * - All rule violations are logged to Cloud Logging by default
 * - View logs: GCP Console > Logging > Logs Explorer
 * - Filter: resource.type="firestore.googleapis.com/rules"
 * - Set up alerts for unusual patterns (repeated denials, ID guessing attempts)
 *
 * ADVERSARIAL PROTECTIONS (NFR85):
 * - ID guessing: Random familyId/childId returns empty, not error
 * - Path traversal: Nested paths validated at each level
 * - Token manipulation: Auth token verified against actual user
 * - Cross-family queries: Filtered server-side, never exposed
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // User profiles: users can only read/write their own document
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Family documents: only guardians can access their family
    // NOTE: Documents must include 'guardianUids' array (list of UID strings) for permission checks
    match /families/{familyId} {
      // Helper function to check if user is a guardian of this family
      function isGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardianUids;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardianUids;
      }

      // Read: only guardians can read family data
      allow read: if isGuardian();

      // Create: authenticated user can create family if they're adding themselves as guardian
      allow create: if request.auth != null && isCreatingAsGuardian();

      // Update: only existing guardians can update family
      // Story 3.4 AC6: Prevent guardian removal in co-managed families
      // Guardians array can only grow or stay same size - no removals allowed
      allow update: if isGuardian() &&
        request.resource.data.guardians.size() >= resource.data.guardians.size();

      // Delete: only guardians can delete their family (single-guardian only)
      // Multi-guardian families require support intervention
      allow delete: if isGuardian() && resource.data.guardians.size() == 1;

      // =============================================================
      // FAMILY SUBCOLLECTIONS - Story 12: Device Enrollment
      // =============================================================

      // Devices subcollection: enrolled devices for this family
      //
      // Story 12.4: Device Registration in Firestore
      // Guardians can view family devices.
      // Creation/updates are done via Cloud Functions for security.
      //
      // Story 13.1: TOTP Secret Storage
      // Device documents contain totpSecret for offline emergency unlock.
      // SECURITY: totpSecret is only readable by guardians (parents) of the family.
      // The secret is encrypted at rest by Firestore default encryption.
      // Extension stores its own copy locally (see enrollment-state.ts).
      //
      match /devices/{deviceId} {
        // Helper: Check if user is a guardian of the parent family document
        function isFamilyDeviceGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view enrolled devices
        allow read: if isFamilyDeviceGuardian();

        // Create: Only Cloud Functions can create (via Admin SDK)
        // Direct client creation is denied for security
        allow create: if false;

        // Update: Guardians can update device settings (name, childId)
        allow update: if isFamilyDeviceGuardian();

        // Delete: Guardians can unenroll devices
        allow delete: if isFamilyDeviceGuardian();
      }

      // Enrollment tokens subcollection: QR code tokens for device enrollment
      //
      // Story 12.1: Enrollment QR Code Generation
      // Guardians can create and view tokens.
      //
      match /enrollmentTokens/{tokenId} {
        function isEnrollmentTokenGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view their tokens
        allow read: if isEnrollmentTokenGuardian();

        // Create: Guardians can create enrollment tokens
        allow create: if isEnrollmentTokenGuardian();

        // Update: Guardians can update token status
        allow update: if isEnrollmentTokenGuardian();

        // Delete: Guardians can delete tokens
        allow delete: if isEnrollmentTokenGuardian();
      }

      // Enrollment requests subcollection: pending device enrollment requests
      //
      // Story 12.3: Device-to-Device Enrollment Approval
      // Guardians can view and manage enrollment requests.
      // Creation is done via Cloud Functions (from extension).
      //
      match /enrollmentRequests/{requestId} {
        function isEnrollmentRequestGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view enrollment requests
        allow read: if isEnrollmentRequestGuardian();

        // Create: Only Cloud Functions can create (from extension)
        allow create: if false;

        // Update: Guardians can approve/reject requests
        allow update: if isEnrollmentRequestGuardian();

        // Delete: Not allowed (keep audit trail)
        allow delete: if false;
      }

      // AI Settings subcollection: family-specific model tuning
      //
      // Story 24.2: Family-Specific Model Tuning
      // Guardians can view AI learning status.
      // Creation/updates are done via Cloud Functions for security.
      //
      match /aiSettings/{settingId} {
        function isAISettingsGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view AI learning status (for UI indicator)
        allow read: if isAISettingsGuardian();

        // Create/Update: Only Cloud Functions can modify (via Admin SDK)
        // This prevents manipulation of AI bias weights
        allow create, update: if false;

        // Delete: Not allowed - AI settings are persistent
        allow delete: if false;
      }

      // Feedback subcollection: correction feedback for AI learning
      //
      // Story 24.2: Family-Specific Model Tuning
      // Guardians can view their correction history.
      // Creation is done via Cloud Functions (onFlagCorrected trigger).
      //
      match /feedback/{feedbackId} {
        function isFeedbackGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view correction feedback (for transparency)
        allow read: if isFeedbackGuardian();

        // Create: Only Cloud Functions can create (via onFlagCorrected trigger)
        // This prevents fake corrections from manipulating AI
        allow create: if false;

        // Update: Only Cloud Functions can mark as processed
        allow update: if false;

        // Delete: Not allowed - feedback is audit trail
        allow delete: if false;
      }
    }

    // Child documents: guardians can access children in their family
    //
    // EPIC 3A DATA SYMMETRY PRINCIPLE (Story 3A.1):
    // Both co-parents in shared custody families MUST have IDENTICAL access.
    // All guardians in the guardians[] array have equal read permissions.
    // No data filtering, delay, or modification based on which guardian views.
    // This prevents information asymmetry in custody situations.
    //
    // STORY 8.1 FAMILY DATA ISOLATION:
    // - Children are only accessible by their guardians
    // - Cross-family access is impossible via these rules
    // - ID guessing returns no data (not errors)
    //
    match /children/{childId} {
      // Helper function to check if user is a guardian of this child
      // DATA SYMMETRY: All guardians in guardians[] have identical access
      function isChildGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardianUids;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardianUids;
      }

      // Helper function to verify user is guardian of the family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth.uid in family.data.guardianUids;
      }

      // Read: only child guardians can read
      // DATA SYMMETRY: Both co-parents see identical data simultaneously
      // ISOLATION: Cross-family/cross-child access denied
      allow read: if isChildGuardian();

      // Create: authenticated user who is guardian of the family
      allow create: if request.auth != null &&
        isCreatingAsGuardian() && isFamilyGuardian();

      // Update: only existing guardians can update
      allow update: if isChildGuardian();

      // Delete: only existing guardians can delete
      allow delete: if isChildGuardian();

      // =============================================================
      // CHILD SUBCOLLECTIONS - Story 8.1 Family Data Isolation
      // =============================================================
      // All child subcollections inherit guardian-based access.
      // This ensures complete data isolation at the child level.

      // Screenshots subcollection: child's captured screenshots
      //
      // SECURITY: Screenshot data is the most sensitive data in fledgely.
      // Only guardians of the specific child can access.
      // Siblings cannot see each other's screenshots (Story 8.2).
      //
      // Story 19B.1: Child can also view their own screenshots
      // Child auth uses custom token with childId claim
      //
      match /screenshots/{screenshotId} {
        // Helper: Check if user is guardian of the parent child document
        function isScreenshotChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Helper: Check if user is the child themselves (via custom token)
        // Story 19B.1: Child authentication uses custom claims
        function isChildOwner() {
          return request.auth != null &&
            request.auth.token.childId == childId;
        }

        // Read: Guardians OR the child themselves can view screenshots
        // DATA SYMMETRY: Both co-parents see same screenshots
        // Story 19B.1 AC6: Child can ONLY view their own screenshots
        allow read: if isScreenshotChildGuardian() || isChildOwner();

        // Create: Only authenticated devices can upload (via Cloud Functions)
        // Direct client upload is denied - must go through validated API
        allow create: if false;

        // Update: Not allowed - screenshots are immutable
        allow update: if false;

        // Delete: Only guardians can delete (for retention policy)
        // Children cannot delete their screenshots
        allow delete: if isScreenshotChildGuardian();
      }

      // Activity subcollection: child's activity logs
      //
      // SECURITY: Activity data includes browsing and app usage.
      // Only guardians of the specific child can access.
      //
      match /activity/{activityId} {
        // Helper: Check if user is guardian of the parent child document
        function isActivityChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Only child's guardians can view activity
        allow read: if isActivityChildGuardian();

        // Create: Only devices can create (via Cloud Functions)
        allow create: if false;

        // Update: Not allowed - activity logs are append-only
        allow update: if false;

        // Delete: Only guardians can delete (for retention policy)
        allow delete: if isActivityChildGuardian();
      }

      // Agreements subcollection: child's agreement documents
      //
      // Story 5-6: Agreement creation, signing, activation
      // Both guardians and the child can read their agreement.
      // Modifications follow approval workflow.
      //
      match /agreements/{agreementId} {
        // Helper: Check if user is guardian of the parent child document
        function isAgreementChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Guardians and the child themselves can read
        // Note: Child auth is implemented in later epics
        allow read: if isAgreementChildGuardian();

        // Create: Guardians can create agreements
        allow create: if isAgreementChildGuardian();

        // Update: Guardians can update (versioning managed by app logic)
        allow update: if isAgreementChildGuardian();

        // Delete: Not allowed - agreements have history
        allow delete: if false;
      }

      // Flags subcollection: AI-generated flags for concerning content
      //
      // Story 21-22: Concerning content detection and review
      // Guardians can view and resolve flags.
      //
      match /flags/{flagId} {
        // Helper: Check if user is guardian of the parent child document
        function isFlagChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Only child's guardians can view flags
        allow read: if isFlagChildGuardian();

        // Create: Only Cloud Functions (AI service) can create
        allow create: if false;

        // Update: Guardians can update (resolve, add notes)
        allow update: if isFlagChildGuardian();

        // Delete: Not allowed - flags are audit trail
        allow delete: if false;
      }

      // Devices subcollection: enrolled devices for this child
      //
      // Story 9-17: Device enrollment and monitoring
      // Guardians can view and manage enrolled devices.
      //
      match /devices/{deviceId} {
        // Helper: Check if user is guardian of the parent child document
        function isDeviceChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Guardians can view enrolled devices
        allow read: if isDeviceChildGuardian();

        // Create: Guardians can enroll devices
        allow create: if isDeviceChildGuardian();

        // Update: Guardians can update device settings
        allow update: if isDeviceChildGuardian();

        // Delete: Guardians can unenroll devices
        allow delete: if isDeviceChildGuardian();
      }
    }

    // Invitation documents: for co-parent invitations
    match /invitations/{invitationId} {
      // Helper to check if user is the inviter
      function isInviter() {
        return request.auth != null &&
          request.auth.uid == resource.data.inviterUid;
      }

      // Helper to check if user is a guardian of the invitation's family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Allow public read for pending invitations (Story 3.3 - AC1)
      // This allows invitees to see invitation details BEFORE signing in.
      // Security: Token is unguessable UUID, and only pending invitations are readable.
      // Authenticated users can read any invitation (for guardians managing invitations).
      allow read: if resource.data.status == 'pending' || request.auth != null;

      // Create: authenticated users can create if they're set as inviter
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.inviterUid;

      // Update: only inviter can update (for revoking, marking expired)
      allow update: if isInviter();

      // Delete: not allowed (use status: revoked instead)
      allow delete: if false;
    }

    // Audit logs: append-only logs for data viewing transparency
    //
    // Story 3A.1: Data Symmetry Enforcement - AC3
    // Records when guardians view child or family data.
    // Story 3A.5: Screenshot Viewing Rate Alert uses this data.
    // Story 12.5: Device assignment audit logs (AC4) - created via Admin SDK (Cloud Functions)
    //
    // AC5 (Future): Access Revocation Symmetry
    // When one parent's access is revoked (Story 3.6 legal petition),
    // audit logs may become inaccessible to both until resolved.
    // This ensures no information asymmetry during dispute resolution.
    //
    match /auditLogs/{logId} {
      // Helper: Check if user is a guardian of the family in the audit log
      function isFamilyGuardianForAudit() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Helper: Check if user is guardian of family for existing audit log
      function canReadFamilyAudit() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Family guardians can read audit logs for their family
      // DATA SYMMETRY: Both co-parents can see all viewing activity
      allow read: if canReadFamilyAudit();

      // Create: Guardians can only log their own views (prevent spoofing)
      // Note: Server-side audit logs (device assignment) use Admin SDK and bypass rules
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.viewerUid &&
        isFamilyGuardianForAudit();

      // Update/Delete: Not allowed (audit trail immutability)
      // Audit logs are append-only for compliance and trust
      allow update, delete: if false;
    }

    // Safety setting change proposals: two-parent approval workflow
    //
    // Story 3A.2: Safety Settings Two-Parent Approval
    // Story 3A.4: Safety Rule 48-Hour Cooling Period
    //
    // In shared custody families, safety-related setting changes require
    // both guardians to approve before taking effect.
    //
    // Key rules:
    // - Only guardians can propose changes for their family
    // - Only the OTHER guardian (not the proposer) can approve/decline
    // - Proposals cannot be self-approved (prevents single-parent override)
    // - Approved/declined/expired changes are immutable (audit trail)
    // - Story 3A.4: Protection reductions enter 48-hour cooling period
    // - Story 3A.4: Either guardian can cancel during cooling period
    //
    match /safetySettingChanges/{changeId} {
      // Helper: Check if user is a guardian of the family for new proposals
      function isFamilyGuardianForCreate() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Helper: Check if user is a guardian of the family for existing changes
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Helper: Check if user is the OTHER guardian (not the proposer)
      // CRITICAL: This prevents self-approval
      function isOtherGuardian() {
        return isFamilyGuardian() &&
          request.auth.uid != resource.data.proposedByUid;
      }

      // Read: Family guardians can read all proposals for their family
      // DATA SYMMETRY: Both co-parents see all pending, approved, and declined changes
      allow read: if isFamilyGuardian();

      // Create: Guardians can propose changes for their family
      // Must set themselves as proposer (prevent impersonation)
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.proposedByUid &&
        isFamilyGuardianForCreate() &&
        request.resource.data.status == 'pending_approval';

      // Update for approval/decline: Only the OTHER guardian can approve/decline
      // - Must be pending_approval to be updated
      // - Story 3A.4: Can transition to approved, declined, OR cooling_period
      // - Cannot transition directly to 'activated' (must go through cooling period)
      // - Cannot modify proposal details, only status and resolution fields
      allow update: if isOtherGuardian() &&
        resource.data.status == 'pending_approval' &&
        request.resource.data.status in ['approved', 'declined', 'cooling_period'] &&
        // Preserve original proposal data (immutability of proposal content)
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.settingType == resource.data.settingType &&
        request.resource.data.currentValue == resource.data.currentValue &&
        request.resource.data.proposedValue == resource.data.proposedValue &&
        request.resource.data.proposedByUid == resource.data.proposedByUid;

      // Story 3A.4: Update for cancellation during cooling period
      // - Either guardian (proposer OR approver) can cancel during cooling period
      // - Must be in cooling_period status
      // - Can only transition to 'cancelled'
      // - Must preserve proposal data immutability
      allow update: if isFamilyGuardian() &&
        resource.data.status == 'cooling_period' &&
        request.resource.data.status == 'cancelled' &&
        // Preserve original proposal data
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.settingType == resource.data.settingType &&
        request.resource.data.currentValue == resource.data.currentValue &&
        request.resource.data.proposedValue == resource.data.proposedValue &&
        request.resource.data.proposedByUid == resource.data.proposedByUid;

      // Delete: Not allowed (keep audit trail)
      // Expired proposals remain for historical reference
      allow delete: if false;
    }

    // Agreement Templates: public read for authenticated users
    //
    // Story 4.1: Template Library Structure - AC7
    //
    // Templates are shared resources that all authenticated users can browse.
    // They provide starting points for family agreements.
    //
    // Key rules:
    // - Any authenticated user can read templates
    // - Write access is denied (templates are managed via admin tools/deployment)
    // - No user-generated content in templates (prevents abuse)
    //
    match /agreementTemplates/{templateId} {
      // Read: Any authenticated user can browse templates
      allow read: if request.auth != null;

      // Write: Not allowed through client SDK
      // Templates are seeded/managed through admin tools or CI/CD
      allow write: if false;
    }

    // =========================================================================
    // STORY 6.3 & 6.5: ACTIVE AGREEMENTS
    // Story 6.3: Agreement Activation
    // Story 6.5: Device Consent Gate
    // =========================================================================
    //
    // SECURITY DESIGN:
    // Active agreements control whether device monitoring is allowed.
    // Only guardians of the family can view their active agreements.
    // Write operations are controlled via Cloud Functions (Admin SDK).
    //
    // Key rules:
    // - Guardians can read active agreements for their family
    // - Only Cloud Functions can create/update (prevents manipulation)
    // - Device consent checks go through Cloud Function (Admin SDK)
    //
    match /activeAgreements/{agreementId} {
      // Helper: Check if user is a guardian of the family
      function isActiveAgreementGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Family guardians can view their active agreements
      // DATA SYMMETRY: Both co-parents see same agreements
      allow read: if isActiveAgreementGuardian();

      // Create: Only Cloud Functions can create (via Admin SDK)
      // This ensures proper validation and workflow enforcement
      allow create: if false;

      // Update: Only Cloud Functions can update (via Admin SDK)
      // Status changes (active -> archived) are controlled by workflow
      allow update: if false;

      // Delete: Not allowed (agreements are archived, not deleted)
      allow delete: if false;
    }

    // =========================================================================
    // STORY 6.6: CONSENT WITHDRAWAL REQUESTS
    // =========================================================================
    //
    // SECURITY DESIGN:
    // Withdrawal requests are child-initiated with a 24-hour cooling period.
    // Only Cloud Functions can create/execute withdrawals.
    // Guardians can view but cannot cancel on child's behalf.
    //
    // Key rules:
    // - Cloud Functions create withdrawals (no direct client creation)
    // - Family guardians can read withdrawal requests for their family
    // - Only Cloud Functions can update status (pending -> cancelled/executed)
    // - Requests are preserved for audit trail
    //
    match /withdrawalRequests/{requestId} {
      // Helper: Check if user is a guardian of the family
      function isWithdrawalFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Family guardians can view withdrawal requests
      // DATA SYMMETRY: Both co-parents see same requests
      // Allows parents to see pending withdrawal and discuss with child
      allow read: if isWithdrawalFamilyGuardian();

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Ensures proper validation of device assignment and active agreement
      allow create: if false;

      // Update: Only Cloud Functions can update (via Admin SDK)
      // Status changes (pending -> cancelled/executed) are controlled
      allow update: if false;

      // Delete: Not allowed (keep audit trail)
      // Withdrawal history is preserved for compliance
      allow delete: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.1: Secure Safety Contact Channel
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Safety tickets are COMPLETELY ISOLATED from all other family data.
    // This prevents an abuser from discovering that a victim contacted support.
    //
    // Key protections:
    // - NO read access for regular users (only support via Admin SDK)
    // - Create allowed from callable function (no direct client writes)
    // - NO cross-references to family documents
    // - NO audit trail entries created for these submissions
    //
    match /safetyTickets/{ticketId} {
      // CRITICAL: Regular users CANNOT read safety tickets
      // Support agents access via Admin SDK (bypasses security rules)
      // This prevents an abuser from discovering a victim's support request
      allow read: if false;

      // Create: Only callable functions can create (via Admin SDK)
      // Direct client creation is denied for security
      // The submitSafetyContact callable function handles creation
      allow create: if false;

      // Update: Only support agents via Admin SDK
      // Regular users cannot modify tickets
      allow update: if false;

      // Delete: NEVER allowed (audit trail preservation)
      // Support tickets are retained for legal/safety documentation
      allow delete: if false;
    }

    // Rate limiting collection for safety contact submissions
    // Used to prevent abuse while allowing legitimate requests
    match /safetyRateLimits/{ipHash} {
      // Only callable functions can read/write (via Admin SDK)
      allow read, write: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.2: Safety Request Documentation Upload
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Safety documents are COMPLETELY ISOLATED from all other family data.
    // This prevents an abuser from discovering uploaded documentation.
    //
    // Key protections:
    // - NO read access for regular users (only support via Admin SDK)
    // - Create/delete allowed only via callable functions
    // - NO cross-references to family documents
    // - Legal hold protection to preserve evidence
    //
    match /safetyDocuments/{documentId} {
      // CRITICAL: Regular users CANNOT read safety documents
      // Support agents access via Admin SDK (bypasses security rules)
      allow read: if false;

      // Create: Only callable functions can create (via Admin SDK)
      allow create: if false;

      // Update: Only Admin SDK for support/legal operations
      allow update: if false;

      // Delete: Only Admin SDK (callable function) with proper checks
      allow delete: if false;
    }

    // Rate limiting collection for safety document uploads
    match /safetyDocumentRateLimits/{ipHash} {
      // Only callable functions can read/write (via Admin SDK)
      allow read, write: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.7: 72-Hour Notification Stealth
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Stealth queue entries hold suppressed notifications during the 72-hour
    // escape window. These entries are COMPLETELY INVISIBLE to family members.
    //
    // Key protections:
    // - NO read access for regular users (only scheduled cleanup via Admin SDK)
    // - NO write access for regular users (only Cloud Functions)
    // - Entries are automatically deleted after 72 hours by scheduled function
    // - NO cross-references to family-visible audit logs
    //
    match /stealthQueueEntries/{entryId} {
      // CRITICAL: Regular users CANNOT read stealth queue entries
      // Scheduled cleanup and admin functions access via Admin SDK
      allow read: if false;

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Notifications are captured when stealth window is active
      allow create: if false;

      // Update: Not allowed - entries are immutable until deleted
      allow update: if false;

      // Delete: Only scheduled cleanup via Admin SDK
      // Entries are deleted after 72-hour window expires
      allow delete: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.8: Audit Trail Sealing
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Sealed audit entries are COMPLETELY ISOLATED from all family data.
    // They are preserved for compliance/legal needs after escape actions.
    //
    // Key protections:
    // - NO read access for regular users (only legal/compliance via Admin SDK)
    // - NO write access for regular users (only Cloud Functions)
    // - Entries retained indefinitely for legal compliance
    // - All access logged to entry's accessLog and admin audit
    //
    match /sealedAuditEntries/{entryId} {
      // CRITICAL: Regular users CANNOT read sealed audit entries
      // Legal/compliance access via Admin SDK (bypasses security rules)
      // This prevents abuser from discovering sealed entries exist
      allow read: if false;

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Entries are created when escape actions seal audit logs
      allow create: if false;

      // Update: Only Admin SDK for access logging
      // Regular users cannot modify sealed entries
      allow update: if false;

      // Delete: NEVER allowed (legal compliance requirement)
      // Sealed entries are preserved indefinitely
      allow delete: if false;
    }

    // =========================================================================
    // EPIC 21: AI CLASSIFICATION - CONCERNING CONTENT DETECTION
    // Story 21.2: Distress Detection Suppression
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Suppression audit entries are COMPLETELY ISOLATED from family data.
    // They log when distress-related flags are suppressed from parent view.
    //
    // Key protections:
    // - NO read access for regular users (admin-only via Admin SDK)
    // - NO write access for regular users (only Cloud Functions)
    // - Entries preserved for internal audit and safety compliance
    // - NO cross-references to family-visible audit logs
    //
    match /suppressionAudit/{entryId} {
      // CRITICAL: Parents CANNOT read suppression audit entries
      // These logs are internal-only to protect children seeking help
      // Admin access via Admin SDK (bypasses security rules)
      allow read: if false;

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Entries are created when distress content is detected and suppressed
      allow create: if false;

      // Update: Only Admin SDK for release tracking
      // Regular users cannot modify suppression entries
      allow update: if false;

      // Delete: NEVER allowed (audit trail preservation)
      // Suppression history is preserved for compliance
      allow delete: if false;
    }

    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
