rules_version = '2';

/**
 * Fledgely Firestore Security Rules
 *
 * Story 8.1: Family Data Isolation Rules
 *
 * SECURITY ARCHITECTURE (SA1):
 * These rules are the PRIMARY security boundary for Fledgely.
 * All rules changes require PR review and automated testing.
 *
 * SECURITY PRINCIPLES:
 * 1. Deny by default - All paths blocked unless explicitly allowed
 * 2. Least privilege - Minimum permissions required for operation
 * 3. User isolation - Users can only access their own data
 * 4. Family isolation - No data leakage across families (NFR14)
 * 5. Guardian-based access - Children accessed only by their guardians
 * 6. Data symmetry - Co-parents have identical access (Epic 3A)
 *
 * SECURITY MONITORING:
 * - All rule violations are logged to Cloud Logging by default
 * - View logs: GCP Console > Logging > Logs Explorer
 * - Filter: resource.type="firestore.googleapis.com/rules"
 * - Set up alerts for unusual patterns (repeated denials, ID guessing attempts)
 *
 * ADVERSARIAL PROTECTIONS (NFR85):
 * - ID guessing: Random familyId/childId returns empty, not error
 * - Path traversal: Nested paths validated at each level
 * - Token manipulation: Auth token verified against actual user
 * - Cross-family queries: Filtered server-side, never exposed
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // User profiles: users can only read/write their own document
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Family documents: only guardians can access their family
    // NOTE: Documents must include 'guardianUids' array (list of UID strings) for permission checks
    match /families/{familyId} {
      // Helper function to check if user is a guardian of this family
      function isGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardianUids;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardianUids;
      }

      // Read: only guardians can read family data
      allow read: if isGuardian();

      // Create: authenticated user can create family if they're adding themselves as guardian
      allow create: if request.auth != null && isCreatingAsGuardian();

      // Update: only existing guardians can update family
      // Story 3.4 AC6: Prevent guardian removal in co-managed families
      // Guardians array can only grow or stay same size - no removals allowed
      allow update: if isGuardian() &&
        request.resource.data.guardians.size() >= resource.data.guardians.size();

      // Delete: only guardians can delete their family (single-guardian only)
      // Multi-guardian families require support intervention
      allow delete: if isGuardian() && resource.data.guardians.size() == 1;

      // =============================================================
      // FAMILY SUBCOLLECTIONS - Story 12: Device Enrollment
      // =============================================================

      // Devices subcollection: enrolled devices for this family
      //
      // Story 12.4: Device Registration in Firestore
      // Guardians can view family devices.
      // Creation/updates are done via Cloud Functions for security.
      //
      // Story 13.1: TOTP Secret Storage
      // Device documents contain totpSecret for offline emergency unlock.
      // SECURITY: totpSecret is only readable by guardians (parents) of the family.
      // The secret is encrypted at rest by Firestore default encryption.
      // Extension stores its own copy locally (see enrollment-state.ts).
      //
      match /devices/{deviceId} {
        // Helper: Check if user is a guardian of the parent family document
        function isFamilyDeviceGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view enrolled devices
        allow read: if isFamilyDeviceGuardian();

        // Create: Only Cloud Functions can create (via Admin SDK)
        // Direct client creation is denied for security
        allow create: if false;

        // Update: Guardians can update device settings (name, childId)
        allow update: if isFamilyDeviceGuardian();

        // Delete: Guardians can unenroll devices
        allow delete: if isFamilyDeviceGuardian();
      }

      // Enrollment tokens subcollection: QR code tokens for device enrollment
      //
      // Story 12.1: Enrollment QR Code Generation
      // Guardians can create and view tokens.
      //
      match /enrollmentTokens/{tokenId} {
        function isEnrollmentTokenGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view their tokens
        allow read: if isEnrollmentTokenGuardian();

        // Create: Guardians can create enrollment tokens
        allow create: if isEnrollmentTokenGuardian();

        // Update: Guardians can update token status
        allow update: if isEnrollmentTokenGuardian();

        // Delete: Guardians can delete tokens
        allow delete: if isEnrollmentTokenGuardian();
      }

      // Enrollment requests subcollection: pending device enrollment requests
      //
      // Story 12.3: Device-to-Device Enrollment Approval
      // Guardians can view and manage enrollment requests.
      // Creation is done via Cloud Functions (from extension).
      //
      match /enrollmentRequests/{requestId} {
        function isEnrollmentRequestGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view enrollment requests
        allow read: if isEnrollmentRequestGuardian();

        // Create: Only Cloud Functions can create (from extension)
        allow create: if false;

        // Update: Guardians can approve/reject requests
        allow update: if isEnrollmentRequestGuardian();

        // Delete: Not allowed (keep audit trail)
        allow delete: if false;
      }

      // AI Settings subcollection: family-specific model tuning
      //
      // Story 24.2: Family-Specific Model Tuning
      // Guardians can view AI learning status.
      // Creation/updates are done via Cloud Functions for security.
      //
      match /aiSettings/{settingId} {
        function isAISettingsGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view AI learning status (for UI indicator)
        allow read: if isAISettingsGuardian();

        // Create/Update: Only Cloud Functions can modify (via Admin SDK)
        // This prevents manipulation of AI bias weights
        allow create, update: if false;

        // Delete: Not allowed - AI settings are persistent
        allow delete: if false;
      }

      // Feedback subcollection: correction feedback for AI learning
      //
      // Story 24.2: Family-Specific Model Tuning
      // Guardians can view their correction history.
      // Creation is done via Cloud Functions (onFlagCorrected trigger).
      //
      match /feedback/{feedbackId} {
        function isFeedbackGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view correction feedback (for transparency)
        allow read: if isFeedbackGuardian();

        // Create: Only Cloud Functions can create (via onFlagCorrected trigger)
        // This prevents fake corrections from manipulating AI
        allow create: if false;

        // Update: Only Cloud Functions can mark as processed
        allow update: if false;

        // Delete: Not allowed - feedback is audit trail
        allow delete: if false;
      }

      // Time Extension Requests subcollection: child requests for more screen time
      //
      // Story 31.6: Time Extension Requests
      // Guardians can view requests and respond (approve/deny).
      // Creation is done via Cloud Functions (from extension HTTP call).
      //
      // SECURITY:
      // - Requests come from unauthenticated extension via HTTP function
      // - Only Cloud Functions can create (validates device enrollment)
      // - Guardians can update status to approve/deny
      //
      match /timeExtensionRequests/{requestId} {
        function isTimeExtensionGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view extension requests
        allow read: if isTimeExtensionGuardian();

        // Create: Only Cloud Functions can create (via Admin SDK)
        // This ensures device enrollment is validated before accepting requests
        allow create: if false;

        // Update: Guardians can approve/deny pending requests
        // Can only change status, respondedAt, respondedBy fields
        allow update: if isTimeExtensionGuardian() &&
          resource.data.status == 'pending' &&
          request.resource.data.status in ['approved', 'denied'] &&
          // Preserve immutable fields
          request.resource.data.childId == resource.data.childId &&
          request.resource.data.familyId == resource.data.familyId &&
          request.resource.data.deviceId == resource.data.deviceId &&
          request.resource.data.reason == resource.data.reason &&
          request.resource.data.extensionMinutes == resource.data.extensionMinutes &&
          request.resource.data.requestedAt == resource.data.requestedAt;

        // Delete: Not allowed - keep audit trail
        allow delete: if false;
      }

      // Daily Counters subcollection: atomic counters for rate limiting
      //
      // Story 31.6: Time Extension Requests
      // Used to prevent race conditions in daily limit enforcement.
      // Only Cloud Functions can read/write these counters.
      //
      match /dailyCounters/{counterId} {
        // Only Cloud Functions can access daily counters
        allow read, write: if false;
      }

      // Time Overrides subcollection: parent-granted emergency overrides
      //
      // Story 31.7: Time Limit Override for Emergencies
      // Guardians can grant and revoke overrides.
      // Extension checks for active overrides via Cloud Function.
      //
      // SECURITY:
      // - Only guardians can create/read overrides
      // - Only guardians can revoke (set active: false)
      // - Cannot delete (keep audit trail)
      //
      match /timeOverrides/{overrideId} {
        function isTimeOverrideGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Read: Guardians can view override history
        allow read: if isTimeOverrideGuardian();

        // Create: Guardians can grant overrides
        // Must set themselves as grantedBy
        allow create: if isTimeOverrideGuardian() &&
          request.resource.data.grantedBy == request.auth.uid &&
          request.resource.data.active == true;

        // Update: Guardians can revoke overrides
        // Can only change active, revokedAt, revokedBy fields
        allow update: if isTimeOverrideGuardian() &&
          resource.data.active == true &&
          request.resource.data.active == false &&
          // Preserve immutable fields
          request.resource.data.childId == resource.data.childId &&
          request.resource.data.familyId == resource.data.familyId &&
          request.resource.data.grantedBy == resource.data.grantedBy &&
          request.resource.data.reason == resource.data.reason &&
          request.resource.data.duration == resource.data.duration &&
          request.resource.data.grantedAt == resource.data.grantedAt &&
          request.resource.data.expiresAt == resource.data.expiresAt;

        // Delete: Not allowed - keep audit trail
        allow delete: if false;
      }

      // Parent Compliance Tracking subcollection: offline time compliance records
      //
      // Story 32.4: Parent Compliance Tracking (FR60)
      // Children can view parent compliance for transparency.
      // Parents can view their own and family compliance.
      // Creation is done via Cloud Functions (from extension).
      //
      // SECURITY:
      // - Guardians can read all compliance records
      // - Children can read compliance records (via custom token)
      // - Only Cloud Functions can create (validates device enrollment)
      // - No updates allowed (immutable audit trail)
      //
      match /parentCompliance/{complianceId} {
        function isComplianceGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Helper: Check if user is a child in this family (via custom token)
        // Story 32.4 AC2: Child can see parent compliance in their dashboard
        function isChildInFamily() {
          return request.auth != null &&
            request.auth.token.familyId == familyId;
        }

        // Read: Guardians AND children can view compliance records
        // Story 32.4 AC2: Child can see parent compliance
        // Story 32.4 AC3: Parents see their own compliance stats
        allow read: if isComplianceGuardian() || isChildInFamily();

        // Create: Only Cloud Functions can create (via Admin SDK)
        // This ensures device enrollment is validated before accepting records
        allow create: if false;

        // Update: Not allowed - compliance records are immutable
        allow update: if false;

        // Delete: Not allowed - keep audit trail
        allow delete: if false;
      }

      // =============================================================
      // Offline Exceptions - Story 32.5
      // =============================================================
      //
      // Story 32.5: Offline Time Exceptions
      // - Guardians can read and create exceptions
      // - Children can read exceptions (for UI display)
      // - Only guardians can update/cancel exceptions
      //
      match /offlineExceptions/{exceptionId} {
        function isExceptionGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Helper: Check if user is a child in this family (via custom token)
        function isChildInFamily() {
          return request.auth != null &&
            request.auth.token.familyId == familyId;
        }

        // Read: Guardians AND children can view exceptions (transparency)
        // Story 32.5 AC6: All exceptions visible to family members
        allow read: if isExceptionGuardian() || isChildInFamily();

        // Create: Only guardians can create exceptions
        // Story 32.5 AC1, AC3, AC5: Parent-initiated exceptions
        allow create: if isExceptionGuardian();

        // Update: Only guardians can update exception status
        // Story 32.5: Cancel or complete exceptions
        allow update: if isExceptionGuardian();

        // Delete: Not allowed - keep audit trail
        allow delete: if false;
      }

      // =========================================================================
      // EPIC 34: AGREEMENT CHANGES & PROPOSALS
      // Story 34.1: Parent-Initiated Agreement Change
      // Story 34.2: Child-Initiated Agreement Change
      // Story 34.3: Change Review and Negotiation
      // =========================================================================
      //
      // Agreement proposals allow parents/children to propose changes to agreements.
      // Guardians can create parent-initiated proposals.
      // Children can create child-initiated proposals for their own agreements.
      // Both guardians and children can read proposals for transparency.
      // Proposals are preserved for audit trail (no deletion).
      //
      match /agreementProposals/{proposalId} {
        // Helper: Check if user is a guardian of this family
        function isProposalGuardian() {
          let family = get(/databases/$(database)/documents/families/$(familyId));
          return request.auth != null &&
            request.auth.uid in family.data.guardianUids;
        }

        // Helper: Check if user is a child in this family (via custom token)
        // Story 34.2: Child authentication uses custom claims
        function isChildInProposalFamily() {
          return request.auth != null &&
            request.auth.token.familyId == familyId;
        }

        // Read: Guardians AND children can view proposals for their family
        // Story 34.1 AC5: Child can review proposals
        // Story 34.2 AC5: Child sees proposal status
        allow read: if isProposalGuardian() || isChildInProposalFamily();

        // Create: Guardians can create parent-initiated proposals
        // Story 34.1 AC4: Parent submits proposal
        // Must set themselves as proposer and start with pending status
        allow create: if isProposalGuardian() &&
          request.resource.data.familyId == familyId &&
          request.resource.data.proposerId == request.auth.uid &&
          request.resource.data.proposedBy == 'parent' &&
          request.resource.data.status == 'pending';

        // Create: Children can create child-initiated proposals
        // Story 34.2 AC3: Child submits proposal
        // Must set themselves as proposer and start with pending status
        // Child can only propose changes for their own agreement
        allow create: if isChildInProposalFamily() &&
          request.resource.data.familyId == familyId &&
          request.resource.data.proposerId == request.auth.uid &&
          request.resource.data.childId == request.auth.token.childId &&
          request.resource.data.proposedBy == 'child' &&
          request.resource.data.status == 'pending';

        // Update: Guardians can withdraw their own proposals
        // Story 34.1 AC6: Proposal can be withdrawn before acceptance
        // Can only change status from pending to withdrawn
        allow update: if isProposalGuardian() &&
          resource.data.proposerId == request.auth.uid &&
          resource.data.status == 'pending' &&
          request.resource.data.status == 'withdrawn' &&
          // Preserve immutable fields
          request.resource.data.familyId == resource.data.familyId &&
          request.resource.data.childId == resource.data.childId &&
          request.resource.data.agreementId == resource.data.agreementId;

        // Update: Children can withdraw their own proposals
        // Story 34.2 AC5: Child can withdraw proposal before parent responds
        // Can only change status from pending to withdrawn
        allow update: if isChildInProposalFamily() &&
          resource.data.proposerId == request.auth.uid &&
          resource.data.proposedBy == 'child' &&
          resource.data.status == 'pending' &&
          request.resource.data.status == 'withdrawn' &&
          // Preserve immutable fields
          request.resource.data.familyId == resource.data.familyId &&
          request.resource.data.childId == resource.data.childId &&
          request.resource.data.agreementId == resource.data.agreementId;

        // Update: Child can respond to parent's proposal
        // Story 34.3 AC2: Accept, Decline, Counter-propose
        // Only the non-proposer can change status to accepted/declined/counter-proposed
        allow update: if isChildInProposalFamily() &&
          resource.data.proposedBy == 'parent' &&
          resource.data.status == 'pending' &&
          request.resource.data.status in ['accepted', 'declined', 'counter-proposed'] &&
          // Preserve immutable fields
          request.resource.data.familyId == resource.data.familyId &&
          request.resource.data.childId == resource.data.childId &&
          request.resource.data.agreementId == resource.data.agreementId &&
          request.resource.data.proposedBy == resource.data.proposedBy &&
          request.resource.data.proposerId == resource.data.proposerId;

        // Update: Parent can respond to child's proposal
        // Story 34.3 AC2: Accept, Decline, Counter-propose
        allow update: if isProposalGuardian() &&
          resource.data.proposedBy == 'child' &&
          resource.data.status == 'pending' &&
          request.resource.data.status in ['accepted', 'declined', 'counter-proposed'] &&
          // Preserve immutable fields
          request.resource.data.familyId == resource.data.familyId &&
          request.resource.data.childId == resource.data.childId &&
          request.resource.data.agreementId == resource.data.agreementId &&
          request.resource.data.proposedBy == resource.data.proposedBy &&
          request.resource.data.proposerId == resource.data.proposerId;

        // Update: Proposer can activate their accepted proposal
        // Story 34.4 AC1, AC2: Dual-signature activation
        // Only the original proposer can activate after acceptance
        allow update: if isProposalGuardian() &&
          resource.data.proposerId == request.auth.uid &&
          resource.data.status == 'accepted' &&
          request.resource.data.status == 'activated' &&
          // Preserve immutable fields
          request.resource.data.familyId == resource.data.familyId &&
          request.resource.data.childId == resource.data.childId &&
          request.resource.data.agreementId == resource.data.agreementId &&
          request.resource.data.proposedBy == resource.data.proposedBy &&
          request.resource.data.proposerId == resource.data.proposerId;

        // Delete: Not allowed - keep audit trail
        // Story 34.1: Proposals are versioned for history tracking
        allow delete: if false;

        // =============================================================
        // RESPONSES SUBCOLLECTION - Story 34.3: Change Review and Negotiation
        // =============================================================
        //
        // Responses are stored as a subcollection under each proposal.
        // Both parties can read responses for transparency.
        // Only the non-proposer can create responses:
        // - Parent proposal → Child responds
        // - Child proposal → Parent responds
        //
        match /responses/{responseId} {
          // Helper: Get the parent proposal document
          function getProposal() {
            return get(/databases/$(database)/documents/families/$(familyId)/agreementProposals/$(proposalId));
          }

          // Helper: Check if user is guardian of the family
          function isResponseGuardian() {
            let family = get(/databases/$(database)/documents/families/$(familyId));
            return request.auth != null &&
              request.auth.uid in family.data.guardianUids;
          }

          // Helper: Check if user is child in the family (via custom token)
          function isResponseChildInFamily() {
            return request.auth != null &&
              request.auth.token.familyId == familyId;
          }

          // Read: Both parties can read responses
          // Story 34.3 AC5: Negotiation history visible to both parties
          allow read: if isResponseGuardian() || isResponseChildInFamily();

          // Create: Only non-proposer can respond
          // Story 34.3 AC2: Accept, Decline, Counter-propose
          // Parent proposal → Child responds
          allow create: if isResponseChildInFamily() &&
            getProposal().data.proposedBy == 'parent' &&
            request.resource.data.responderId == request.auth.uid &&
            request.resource.data.proposalId == proposalId &&
            request.resource.data.action in ['accept', 'decline', 'counter'];

          // Create: Child proposal → Parent responds
          allow create: if isResponseGuardian() &&
            getProposal().data.proposedBy == 'child' &&
            request.resource.data.responderId == request.auth.uid &&
            request.resource.data.proposalId == proposalId &&
            request.resource.data.action in ['accept', 'decline', 'counter'];

          // Update: Not allowed - responses are immutable
          allow update: if false;

          // Delete: Not allowed - keep audit trail
          allow delete: if false;
        }
      }
    }

    // Child documents: guardians can access children in their family
    //
    // EPIC 3A DATA SYMMETRY PRINCIPLE (Story 3A.1):
    // Both co-parents in shared custody families MUST have IDENTICAL access.
    // All guardians in the guardians[] array have equal read permissions.
    // No data filtering, delay, or modification based on which guardian views.
    // This prevents information asymmetry in custody situations.
    //
    // STORY 8.1 FAMILY DATA ISOLATION:
    // - Children are only accessible by their guardians
    // - Cross-family access is impossible via these rules
    // - ID guessing returns no data (not errors)
    //
    match /children/{childId} {
      // Helper function to check if user is a guardian of this child
      // DATA SYMMETRY: All guardians in guardians[] have identical access
      function isChildGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardianUids;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardianUids;
      }

      // Helper function to verify user is guardian of the family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth.uid in family.data.guardianUids;
      }

      // Read: only child guardians can read
      // DATA SYMMETRY: Both co-parents see identical data simultaneously
      // ISOLATION: Cross-family/cross-child access denied
      allow read: if isChildGuardian();

      // Create: authenticated user who is guardian of the family
      allow create: if request.auth != null &&
        isCreatingAsGuardian() && isFamilyGuardian();

      // Update: only existing guardians can update
      allow update: if isChildGuardian();

      // Delete: only existing guardians can delete
      allow delete: if isChildGuardian();

      // =============================================================
      // CHILD SUBCOLLECTIONS - Story 8.1 Family Data Isolation
      // =============================================================
      // All child subcollections inherit guardian-based access.
      // This ensures complete data isolation at the child level.

      // Screenshots subcollection: child's captured screenshots
      //
      // SECURITY: Screenshot data is the most sensitive data in fledgely.
      // Only guardians of the specific child can access.
      // Siblings cannot see each other's screenshots (Story 8.2).
      //
      // Story 19B.1: Child can also view their own screenshots
      // Child auth uses custom token with childId claim
      //
      match /screenshots/{screenshotId} {
        // Helper: Check if user is guardian of the parent child document
        function isScreenshotChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Helper: Check if user is the child themselves (via custom token)
        // Story 19B.1: Child authentication uses custom claims
        function isChildOwner() {
          return request.auth != null &&
            request.auth.token.childId == childId;
        }

        // Read: Guardians OR the child themselves can view screenshots
        // DATA SYMMETRY: Both co-parents see same screenshots
        // Story 19B.1 AC6: Child can ONLY view their own screenshots
        allow read: if isScreenshotChildGuardian() || isChildOwner();

        // Create: Only authenticated devices can upload (via Cloud Functions)
        // Direct client upload is denied - must go through validated API
        allow create: if false;

        // Update: Not allowed - screenshots are immutable
        allow update: if false;

        // Delete: Only guardians can delete (for retention policy)
        // Children cannot delete their screenshots
        allow delete: if isScreenshotChildGuardian();
      }

      // Activity subcollection: child's activity logs
      //
      // SECURITY: Activity data includes browsing and app usage.
      // Only guardians of the specific child can access.
      //
      match /activity/{activityId} {
        // Helper: Check if user is guardian of the parent child document
        function isActivityChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Only child's guardians can view activity
        allow read: if isActivityChildGuardian();

        // Create: Only devices can create (via Cloud Functions)
        allow create: if false;

        // Update: Not allowed - activity logs are append-only
        allow update: if false;

        // Delete: Only guardians can delete (for retention policy)
        allow delete: if isActivityChildGuardian();
      }

      // Agreements subcollection: child's agreement documents
      //
      // Story 5-6: Agreement creation, signing, activation
      // Both guardians and the child can read their agreement.
      // Modifications follow approval workflow.
      //
      match /agreements/{agreementId} {
        // Helper: Check if user is guardian of the parent child document
        function isAgreementChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Helper: Check if user is the child themselves (via custom token)
        function isChildAgreementOwner() {
          return request.auth != null &&
            request.auth.token.childId == childId;
        }

        // Read: Guardians and the child themselves can read
        // Note: Child auth is implemented in later epics
        allow read: if isAgreementChildGuardian() || isChildAgreementOwner();

        // Create: Guardians can create agreements
        allow create: if isAgreementChildGuardian();

        // Update: Guardians can update (versioning managed by app logic)
        allow update: if isAgreementChildGuardian();

        // Delete: Not allowed - agreements have history
        allow delete: if false;

        // =============================================================
        // VERSIONS SUBCOLLECTION - Story 34.4: Dual-Signature Activation
        // =============================================================
        //
        // Stores immutable snapshots of agreement versions with dual signatures.
        // Created when both parties confirm changes via proposal workflow.
        //
        // SECURITY:
        // - Guardians and children can read version history
        // - Creation is done via Cloud Functions (or transaction in hook)
        // - Versions are IMMUTABLE after creation (audit trail)
        //
        match /versions/{versionId} {
          // Read: Both parties can read version history
          // Story 34.4 AC6: History visible to both parties
          allow read: if isAgreementChildGuardian() || isChildAgreementOwner();

          // Create: Guardians can create versions (via activation transaction)
          // Story 34.4 AC3: New version created on activation
          allow create: if isAgreementChildGuardian();

          // Update: NEVER allowed - versions are immutable for audit
          // Story 34.4 AC2: Signatures cannot be altered after recording
          allow update: if false;

          // Delete: NEVER allowed - keep audit trail
          // Story 34.4 AC6: History preserved
          allow delete: if false;
        }
      }

      // Flags subcollection: AI-generated flags for concerning content
      //
      // Story 21-22: Concerning content detection and review
      // Guardians can view and resolve flags.
      //
      match /flags/{flagId} {
        // Helper: Check if user is guardian of the parent child document
        function isFlagChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Only child's guardians can view flags
        allow read: if isFlagChildGuardian();

        // Create: Only Cloud Functions (AI service) can create
        allow create: if false;

        // Update: Guardians can update (resolve, add notes)
        allow update: if isFlagChildGuardian();

        // Delete: Not allowed - flags are audit trail
        allow delete: if false;
      }

      // Devices subcollection: enrolled devices for this child
      //
      // Story 9-17: Device enrollment and monitoring
      // Guardians can view and manage enrolled devices.
      //
      match /devices/{deviceId} {
        // Helper: Check if user is guardian of the parent child document
        function isDeviceChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Guardians can view enrolled devices
        allow read: if isDeviceChildGuardian();

        // Create: Guardians can enroll devices
        allow create: if isDeviceChildGuardian();

        // Update: Guardians can update device settings
        allow update: if isDeviceChildGuardian();

        // Delete: Guardians can unenroll devices
        allow delete: if isDeviceChildGuardian();
      }

      // App Approvals subcollection: per-app category approvals
      //
      // Story 24.3: Explicit Approval of Categories
      // Guardians can set app-specific category approvals per child.
      // Approved apps get reduced flag sensitivity, disapproved get increased.
      //
      match /appApprovals/{approvalId} {
        // Helper: Check if user is guardian of the parent child document
        function isAppApprovalChildGuardian() {
          let child = get(/databases/$(database)/documents/children/$(childId));
          return request.auth != null &&
            request.auth.uid in child.data.guardianUids;
        }

        // Read: Only child's guardians can view app approvals
        allow read: if isAppApprovalChildGuardian();

        // Create: Guardians can create app approvals
        allow create: if isAppApprovalChildGuardian();

        // Update: Guardians can update approvals
        allow update: if isAppApprovalChildGuardian();

        // Delete: Guardians can remove approvals
        allow delete: if isAppApprovalChildGuardian();
      }
    }

    // Invitation documents: for co-parent invitations
    match /invitations/{invitationId} {
      // Helper to check if user is the inviter
      function isInviter() {
        return request.auth != null &&
          request.auth.uid == resource.data.inviterUid;
      }

      // Helper to check if user is a guardian of the invitation's family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Allow public read for pending invitations (Story 3.3 - AC1)
      // This allows invitees to see invitation details BEFORE signing in.
      // Security: Token is unguessable UUID, and only pending invitations are readable.
      // Authenticated users can read any invitation (for guardians managing invitations).
      allow read: if resource.data.status == 'pending' || request.auth != null;

      // Create: authenticated users can create if they're set as inviter
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.inviterUid;

      // Update: only inviter can update (for revoking, marking expired)
      allow update: if isInviter();

      // Delete: not allowed (use status: revoked instead)
      allow delete: if false;
    }

    // Audit logs: append-only logs for data viewing transparency
    //
    // Story 3A.1: Data Symmetry Enforcement - AC3
    // Records when guardians view child or family data.
    // Story 3A.5: Screenshot Viewing Rate Alert uses this data.
    // Story 12.5: Device assignment audit logs (AC4) - created via Admin SDK (Cloud Functions)
    //
    // AC5 (Future): Access Revocation Symmetry
    // When one parent's access is revoked (Story 3.6 legal petition),
    // audit logs may become inaccessible to both until resolved.
    // This ensures no information asymmetry during dispute resolution.
    //
    match /auditLogs/{logId} {
      // Helper: Check if user is a guardian of the family in the audit log
      function isFamilyGuardianForAudit() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Helper: Check if user is guardian of family for existing audit log
      function canReadFamilyAudit() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Family guardians can read audit logs for their family
      // DATA SYMMETRY: Both co-parents can see all viewing activity
      allow read: if canReadFamilyAudit();

      // Create: Guardians can only log their own views (prevent spoofing)
      // Note: Server-side audit logs (device assignment) use Admin SDK and bypass rules
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.viewerUid &&
        isFamilyGuardianForAudit();

      // Update/Delete: Not allowed (audit trail immutability)
      // Audit logs are append-only for compliance and trust
      allow update, delete: if false;
    }

    // =========================================================================
    // Story 27.1: Comprehensive Audit Event Capture
    // =========================================================================
    //
    // Audit events are the comprehensive logging system for all data access.
    // They extend the basic auditLogs with full device/session context.
    //
    // Key features:
    // - Append-only (NFR58: tamper-evident)
    // - 2-year retention (NFR58)
    // - Family guardians can read their family's events
    // - Only Cloud Functions can write (via Admin SDK)
    //
    // FRs: FR32, FR53
    // NFRs: NFR58, NFR82
    //
    match /auditEvents/{eventId} {
      // Helper: Check if user is guardian of family for existing audit event
      function canReadFamilyAuditEvent() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Family guardians can read audit events for their family
      // DATA SYMMETRY: Both co-parents can see all access activity
      allow read: if canReadFamilyAuditEvent();

      // Create: Only Cloud Functions can create (via Admin SDK)
      // This ensures proper retry/dead-letter handling
      allow create: if false;

      // Update/Delete: NEVER allowed (append-only, tamper-evident)
      // Audit events are immutable for compliance and trust
      allow update, delete: if false;
    }

    // Dead-letter queue for failed audit writes
    // Story 27.1: AC5 - Reliable writes with retry mechanism
    //
    // These entries are processed by scheduled functions and should
    // never be accessible to regular users.
    //
    match /auditFailures/{failureId} {
      // CRITICAL: Regular users CANNOT access dead-letter queue
      // Only Cloud Functions via Admin SDK
      allow read, write: if false;
    }

    // Safety setting change proposals: two-parent approval workflow
    //
    // Story 3A.2: Safety Settings Two-Parent Approval
    // Story 3A.4: Safety Rule 48-Hour Cooling Period
    //
    // In shared custody families, safety-related setting changes require
    // both guardians to approve before taking effect.
    //
    // Key rules:
    // - Only guardians can propose changes for their family
    // - Only the OTHER guardian (not the proposer) can approve/decline
    // - Proposals cannot be self-approved (prevents single-parent override)
    // - Approved/declined/expired changes are immutable (audit trail)
    // - Story 3A.4: Protection reductions enter 48-hour cooling period
    // - Story 3A.4: Either guardian can cancel during cooling period
    //
    match /safetySettingChanges/{changeId} {
      // Helper: Check if user is a guardian of the family for new proposals
      function isFamilyGuardianForCreate() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Helper: Check if user is a guardian of the family for existing changes
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Helper: Check if user is the OTHER guardian (not the proposer)
      // CRITICAL: This prevents self-approval
      function isOtherGuardian() {
        return isFamilyGuardian() &&
          request.auth.uid != resource.data.proposedByUid;
      }

      // Read: Family guardians can read all proposals for their family
      // DATA SYMMETRY: Both co-parents see all pending, approved, and declined changes
      allow read: if isFamilyGuardian();

      // Create: Guardians can propose changes for their family
      // Must set themselves as proposer (prevent impersonation)
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.proposedByUid &&
        isFamilyGuardianForCreate() &&
        request.resource.data.status == 'pending_approval';

      // Update for approval/decline: Only the OTHER guardian can approve/decline
      // - Must be pending_approval to be updated
      // - Story 3A.4: Can transition to approved, declined, OR cooling_period
      // - Cannot transition directly to 'activated' (must go through cooling period)
      // - Cannot modify proposal details, only status and resolution fields
      allow update: if isOtherGuardian() &&
        resource.data.status == 'pending_approval' &&
        request.resource.data.status in ['approved', 'declined', 'cooling_period'] &&
        // Preserve original proposal data (immutability of proposal content)
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.settingType == resource.data.settingType &&
        request.resource.data.currentValue == resource.data.currentValue &&
        request.resource.data.proposedValue == resource.data.proposedValue &&
        request.resource.data.proposedByUid == resource.data.proposedByUid;

      // Story 3A.4: Update for cancellation during cooling period
      // - Either guardian (proposer OR approver) can cancel during cooling period
      // - Must be in cooling_period status
      // - Can only transition to 'cancelled'
      // - Must preserve proposal data immutability
      allow update: if isFamilyGuardian() &&
        resource.data.status == 'cooling_period' &&
        request.resource.data.status == 'cancelled' &&
        // Preserve original proposal data
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.settingType == resource.data.settingType &&
        request.resource.data.currentValue == resource.data.currentValue &&
        request.resource.data.proposedValue == resource.data.proposedValue &&
        request.resource.data.proposedByUid == resource.data.proposedByUid;

      // Delete: Not allowed (keep audit trail)
      // Expired proposals remain for historical reference
      allow delete: if false;
    }

    // Agreement Templates: public read for authenticated users
    //
    // Story 4.1: Template Library Structure - AC7
    //
    // Templates are shared resources that all authenticated users can browse.
    // They provide starting points for family agreements.
    //
    // Key rules:
    // - Any authenticated user can read templates
    // - Write access is denied (templates are managed via admin tools/deployment)
    // - No user-generated content in templates (prevents abuse)
    //
    match /agreementTemplates/{templateId} {
      // Read: Any authenticated user can browse templates
      allow read: if request.auth != null;

      // Write: Not allowed through client SDK
      // Templates are seeded/managed through admin tools or CI/CD
      allow write: if false;
    }

    // =========================================================================
    // STORY 6.3 & 6.5: ACTIVE AGREEMENTS
    // Story 6.3: Agreement Activation
    // Story 6.5: Device Consent Gate
    // =========================================================================
    //
    // SECURITY DESIGN:
    // Active agreements control whether device monitoring is allowed.
    // Only guardians of the family can view their active agreements.
    // Write operations are controlled via Cloud Functions (Admin SDK).
    //
    // Key rules:
    // - Guardians can read active agreements for their family
    // - Only Cloud Functions can create/update (prevents manipulation)
    // - Device consent checks go through Cloud Function (Admin SDK)
    //
    match /activeAgreements/{agreementId} {
      // Helper: Check if user is a guardian of the family
      function isActiveAgreementGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Family guardians can view their active agreements
      // DATA SYMMETRY: Both co-parents see same agreements
      allow read: if isActiveAgreementGuardian();

      // Create: Only Cloud Functions can create (via Admin SDK)
      // This ensures proper validation and workflow enforcement
      allow create: if false;

      // Update: Only Cloud Functions can update (via Admin SDK)
      // Status changes (active -> archived) are controlled by workflow
      allow update: if false;

      // Delete: Not allowed (agreements are archived, not deleted)
      allow delete: if false;
    }

    // =========================================================================
    // STORY 6.6: CONSENT WITHDRAWAL REQUESTS
    // =========================================================================
    //
    // SECURITY DESIGN:
    // Withdrawal requests are child-initiated with a 24-hour cooling period.
    // Only Cloud Functions can create/execute withdrawals.
    // Guardians can view but cannot cancel on child's behalf.
    //
    // Key rules:
    // - Cloud Functions create withdrawals (no direct client creation)
    // - Family guardians can read withdrawal requests for their family
    // - Only Cloud Functions can update status (pending -> cancelled/executed)
    // - Requests are preserved for audit trail
    //
    match /withdrawalRequests/{requestId} {
      // Helper: Check if user is a guardian of the family
      function isWithdrawalFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardianUids;
      }

      // Read: Family guardians can view withdrawal requests
      // DATA SYMMETRY: Both co-parents see same requests
      // Allows parents to see pending withdrawal and discuss with child
      allow read: if isWithdrawalFamilyGuardian();

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Ensures proper validation of device assignment and active agreement
      allow create: if false;

      // Update: Only Cloud Functions can update (via Admin SDK)
      // Status changes (pending -> cancelled/executed) are controlled
      allow update: if false;

      // Delete: Not allowed (keep audit trail)
      // Withdrawal history is preserved for compliance
      allow delete: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.1: Secure Safety Contact Channel
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Safety tickets are COMPLETELY ISOLATED from all other family data.
    // This prevents an abuser from discovering that a victim contacted support.
    //
    // Key protections:
    // - NO read access for regular users (only support via Admin SDK)
    // - Create allowed from callable function (no direct client writes)
    // - NO cross-references to family documents
    // - NO audit trail entries created for these submissions
    //
    match /safetyTickets/{ticketId} {
      // CRITICAL: Regular users CANNOT read safety tickets
      // Support agents access via Admin SDK (bypasses security rules)
      // This prevents an abuser from discovering a victim's support request
      allow read: if false;

      // Create: Only callable functions can create (via Admin SDK)
      // Direct client creation is denied for security
      // The submitSafetyContact callable function handles creation
      allow create: if false;

      // Update: Only support agents via Admin SDK
      // Regular users cannot modify tickets
      allow update: if false;

      // Delete: NEVER allowed (audit trail preservation)
      // Support tickets are retained for legal/safety documentation
      allow delete: if false;
    }

    // Rate limiting collection for safety contact submissions
    // Used to prevent abuse while allowing legitimate requests
    match /safetyRateLimits/{ipHash} {
      // Only callable functions can read/write (via Admin SDK)
      allow read, write: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.2: Safety Request Documentation Upload
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Safety documents are COMPLETELY ISOLATED from all other family data.
    // This prevents an abuser from discovering uploaded documentation.
    //
    // Key protections:
    // - NO read access for regular users (only support via Admin SDK)
    // - Create/delete allowed only via callable functions
    // - NO cross-references to family documents
    // - Legal hold protection to preserve evidence
    //
    match /safetyDocuments/{documentId} {
      // CRITICAL: Regular users CANNOT read safety documents
      // Support agents access via Admin SDK (bypasses security rules)
      allow read: if false;

      // Create: Only callable functions can create (via Admin SDK)
      allow create: if false;

      // Update: Only Admin SDK for support/legal operations
      allow update: if false;

      // Delete: Only Admin SDK (callable function) with proper checks
      allow delete: if false;
    }

    // Rate limiting collection for safety document uploads
    match /safetyDocumentRateLimits/{ipHash} {
      // Only callable functions can read/write (via Admin SDK)
      allow read, write: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.7: 72-Hour Notification Stealth
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Stealth queue entries hold suppressed notifications during the 72-hour
    // escape window. These entries are COMPLETELY INVISIBLE to family members.
    //
    // Key protections:
    // - NO read access for regular users (only scheduled cleanup via Admin SDK)
    // - NO write access for regular users (only Cloud Functions)
    // - Entries are automatically deleted after 72 hours by scheduled function
    // - NO cross-references to family-visible audit logs
    //
    match /stealthQueueEntries/{entryId} {
      // CRITICAL: Regular users CANNOT read stealth queue entries
      // Scheduled cleanup and admin functions access via Admin SDK
      allow read: if false;

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Notifications are captured when stealth window is active
      allow create: if false;

      // Update: Not allowed - entries are immutable until deleted
      allow update: if false;

      // Delete: Only scheduled cleanup via Admin SDK
      // Entries are deleted after 72-hour window expires
      allow delete: if false;
    }

    // =========================================================================
    // EPIC 0.5: SAFE ACCOUNT ESCAPE
    // Story 0.5.8: Audit Trail Sealing
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Sealed audit entries are COMPLETELY ISOLATED from all family data.
    // They are preserved for compliance/legal needs after escape actions.
    //
    // Key protections:
    // - NO read access for regular users (only legal/compliance via Admin SDK)
    // - NO write access for regular users (only Cloud Functions)
    // - Entries retained indefinitely for legal compliance
    // - All access logged to entry's accessLog and admin audit
    //
    match /sealedAuditEntries/{entryId} {
      // CRITICAL: Regular users CANNOT read sealed audit entries
      // Legal/compliance access via Admin SDK (bypasses security rules)
      // This prevents abuser from discovering sealed entries exist
      allow read: if false;

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Entries are created when escape actions seal audit logs
      allow create: if false;

      // Update: Only Admin SDK for access logging
      // Regular users cannot modify sealed entries
      allow update: if false;

      // Delete: NEVER allowed (legal compliance requirement)
      // Sealed entries are preserved indefinitely
      allow delete: if false;
    }

    // =========================================================================
    // EPIC 7.5: CHILD SAFETY SIGNAL
    // Story 7.5.1: Hidden Safety Signal Access (AC6: Signal Isolation)
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Safety signals are COMPLETELY ISOLATED from all family data.
    // These signals NEVER appear in any family-visible query or audit.
    //
    // Key protections:
    // - NO read access for family members (only crisis partners via Admin SDK)
    // - Only children can create their own signals (authenticated child)
    // - Only Cloud Functions can update status (for delivery tracking)
    // - NEVER delete (audit trail preservation for crisis response)
    //
    // Signal flow:
    // 1. Child triggers signal via hidden gesture (web/extension)
    // 2. Signal stored in isolated collection
    // 3. Cloud Functions route to external crisis partners (Story 7.5.2)
    // 4. Family NEVER notified for 48 hours (Story 7.5.7)
    //
    match /safetySignals/{signalId} {
      // CRITICAL: Regular users (parents/guardians) CANNOT read safety signals
      // Crisis partners access via Admin SDK (bypasses security rules)
      // This protects children from abuser discovering signal was sent
      allow read: if false;

      // Create: Only authenticated users can create their own signal
      // Child authentication uses custom token with childId claim
      // Web app users have request.auth.uid available
      // The childId in the signal must match the authenticated user
      allow create: if request.auth != null &&
        request.resource.data.childId == request.auth.uid;

      // Update: Only Cloud Functions can update (via Admin SDK)
      // Status changes (queued -> pending -> sent -> delivered) are controlled
      allow update: if false;

      // Delete: NEVER allowed (critical audit trail for crisis response)
      // Signals are preserved for crisis partner documentation
      allow delete: if false;
    }

    // Signal trigger events for analytics (admin only)
    // Story 7.5.1 AC6: Trigger event logging
    match /safetySignalTriggerEvents/{eventId} {
      // CRITICAL: No user access - admin analytics only
      allow read, write: if false;
    }

    // =========================================================================
    // EPIC 7.5: CHILD SAFETY SIGNAL
    // Story 7.5.2: External Signal Routing
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Crisis partner data and routing records are COMPLETELY ISOLATED.
    // Only Cloud Functions (Admin SDK) can access these collections.
    //
    // Collections:
    // - crisisPartners: External crisis organization webhooks
    // - signalRoutingResults: Records of signals sent to partners
    // - blackoutRecords: 48-hour family notification blackout periods
    //
    // Key protections:
    // - NO user access (parents, children, or guardians)
    // - Only Cloud Functions via Admin SDK
    // - Webhook URLs and API keys protected
    // - Routing audit trail preserved
    //

    // Crisis Partners: External crisis organizations
    // Only accessible by system administrators via Admin SDK
    match /crisisPartners/{partnerId} {
      // CRITICAL: No user access - admin only via Admin SDK
      // Partner webhook URLs and API keys must be protected
      allow read, write: if false;
    }

    // Signal Routing Results: Records of signals sent to partners
    // Only accessible by Cloud Functions for routing workflow
    match /signalRoutingResults/{resultId} {
      // CRITICAL: No user access - Cloud Functions only
      // Family members must NEVER see routing status
      allow read, write: if false;
    }

    // Blackout Records: 48-hour family notification blackout periods
    // AC5: No family notification for 48 hours
    match /blackoutRecords/{blackoutId} {
      // CRITICAL: No user access - Cloud Functions only
      // Parents must NEVER see blackout records exist
      allow read, write: if false;
    }

    // =========================================================================
    // EPIC 7.5: CHILD SAFETY SIGNAL
    // Story 7.5.6: Signal Encryption & Isolation
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // These collections are COMPLETELY ISOLATED from family document hierarchy.
    // Collections are at ROOT level (not under families/) to prevent path traversal.
    //
    // Key protections:
    // - NO read access for any family member (guardians, parents, children)
    // - Only Admin with specific authorization claims can read
    // - Only Cloud Functions can write (via Admin SDK)
    // - Family encryption keys CANNOT decrypt signal data (AC2)
    // - All access is logged to admin audit trail (AC5)
    //

    // Isolated Safety Signals: Encrypted signal data stored outside family hierarchy
    // AC1: Signal stored in isolated collection (not under family document)
    // AC4: Signal excluded from family audit trail
    match /isolatedSafetySignals/{signalId} {
      // CRITICAL: NO READ for any user except admin with specific claim
      // This ensures complete family isolation
      allow read: if request.auth != null
                  && request.auth.token.signalAccessAuthorization != null;

      // WRITE only via Cloud Functions (not client)
      // All writes must go through validated server-side logic
      allow write: if false;
    }

    // Signal Encryption Keys: Isolated key management for safety signals
    // AC2: Signal uses separate encryption key (not family key)
    // AC5: Admin access requires authorization
    match /signalEncryptionKeys/{keyId} {
      // CRITICAL: NO READ for any user except admin with specific claim
      // Keys are completely isolated from family encryption
      allow read: if request.auth != null
                  && request.auth.token.keyManagementAuthorization != null;

      // WRITE only via Cloud Functions
      // Key generation and management is server-controlled
      allow write: if false;
    }

    // Signal Access Authorizations: Admin authorization for signal access
    // AC5: Admin access requires authorization with separate approver
    match /signalAccessAuthorizations/{authorizationId} {
      // CRITICAL: Only admin users with authorization management claim
      // This prevents unauthorized access to authorization records
      allow read: if request.auth != null
                  && request.auth.token.authorizationManagement == true;

      // Create: Only Cloud Functions (approval workflow)
      // Authorizations require server-side validation
      allow create: if false;

      // Update: Only Cloud Functions (for marking as used)
      allow update: if false;

      // Delete: NEVER allowed (audit trail preservation)
      allow delete: if false;
    }

    // Signal Retention Status: Legal retention tracking for signals
    // AC6: Legal retention requirements per jurisdiction
    match /signalRetentionStatus/{statusId} {
      // CRITICAL: Only admin users with retention management claim
      allow read: if request.auth != null
                  && request.auth.token.retentionManagement == true;

      // WRITE only via Cloud Functions
      // Retention status changes require server-side validation
      allow write: if false;
    }

    // Signal Blackouts: Family notification suppression during investigation
    // Used by partnerEscalationService for AC3 blackout extensions
    match /signalBlackouts/{blackoutId} {
      // CRITICAL: No user access - Cloud Functions only
      // Family members must NEVER see blackout records
      allow read, write: if false;
    }

    // =========================================================================
    // EPIC 21: AI CLASSIFICATION - CONCERNING CONTENT DETECTION
    // Story 21.2: Distress Detection Suppression
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Suppression audit entries are COMPLETELY ISOLATED from family data.
    // They log when distress-related flags are suppressed from parent view.
    //
    // Key protections:
    // - NO read access for regular users (admin-only via Admin SDK)
    // - NO write access for regular users (only Cloud Functions)
    // - Entries preserved for internal audit and safety compliance
    // - NO cross-references to family-visible audit logs
    //
    match /suppressionAudit/{entryId} {
      // CRITICAL: Parents CANNOT read suppression audit entries
      // These logs are internal-only to protect children seeking help
      // Admin access via Admin SDK (bypasses security rules)
      allow read: if false;

      // Create: Only Cloud Functions can create (via Admin SDK)
      // Entries are created when distress content is detected and suppressed
      allow create: if false;

      // Update: Only Admin SDK for release tracking
      // Regular users cannot modify suppression entries
      allow update: if false;

      // Delete: NEVER allowed (audit trail preservation)
      // Suppression history is preserved for compliance
      allow delete: if false;
    }

    // =========================================================================
    // EPIC 34.5: CHILD VOICE ESCALATION - REJECTION PATTERN TRACKING
    // Story 34.5.1: Rejection Pattern Tracking
    // =========================================================================
    //
    // CRITICAL SAFETY DESIGN:
    // Rejection patterns track when children's proposals are declined.
    // This surfaces communication breakdowns and empowers child voice.
    //
    // Privacy principles:
    // - Aggregate patterns only (no proposal content stored)
    // - Family-visible to promote transparency
    // - Child rights focused - surfaces when voice isn't being heard
    //

    // Rejection Patterns: Aggregate pattern data per child (family-visible)
    match /rejectionPatterns/{patternId} {
      // Read: Family members can read their own family's patterns (transparency)
      allow read: if request.auth != null
                  && (
                    // Guardian with matching familyId claim
                    request.auth.token.familyId == resource.data.familyId ||
                    // Or child with matching childId
                    (request.auth.token.childId != null &&
                     request.auth.token.childId == resource.data.childId)
                  );

      // Write: Only Cloud Functions (via Admin SDK)
      // Pattern updates require server-side validation
      allow create, update: if false;

      // Delete: NEVER allowed (audit trail preservation)
      allow delete: if false;
    }

    // Rejection Events: Individual events (system-only for privacy)
    match /rejectionEvents/{eventId} {
      // CRITICAL: Only system access (Cloud Functions via Admin SDK)
      // Individual rejection events contain proposal references
      // Family members should not see individual events (only aggregates)
      allow read: if false;

      // Write: Only Cloud Functions
      allow create, update: if false;

      // Delete: NEVER allowed (audit trail)
      allow delete: if false;
    }

    // Escalation Events: Threshold breach events (family-visible)
    match /escalationEvents/{eventId} {
      // Read: Family members can read their escalations (transparency)
      allow read: if request.auth != null
                  && (
                    // Guardian with matching familyId claim
                    request.auth.token.familyId == resource.data.familyId ||
                    // Or child with matching childId
                    (request.auth.token.childId != null &&
                     request.auth.token.childId == resource.data.childId)
                  );

      // Write: Only Cloud Functions
      allow create, update: if false;

      // Delete: NEVER allowed (audit trail preservation)
      allow delete: if false;
    }

    // Escalation Notifications: Queued notifications for guardians (system-only)
    // Story 34.5.1 AC3: Escalation notification is queued
    match /escalationNotifications/{notificationId} {
      // CRITICAL: Only Cloud Functions can access (system-only for processing)
      // Cloud Functions process these to create actual user notifications
      allow read: if false;

      // Write: Only Cloud Functions
      allow create, update: if false;

      // Delete: Only Cloud Functions after processing
      allow delete: if false;
    }

    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
