rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // SAFETY REQUESTS COLLECTION
    // ============================================
    // CRITICAL: This is a life-safety feature for victims escaping abuse.
    // These rules ensure safety requests are NEVER visible to family members.
    //
    // Security invariants:
    // 1. Anyone can create (supports anonymous submissions from non-authenticated users)
    // 2. Only safety-team or admin can read/update
    // 3. NEVER delete - compliance requirement
    // 4. NEVER linked to family audit trail
    // ============================================

    match /safetyRequests/{requestId} {
      // Anyone can create a safety request (even unauthenticated users)
      // This is intentional - victims may not be logged in or may be
      // using someone else's device
      allow create: if true;

      // Only support team members can read safety requests
      // This prevents family members from ever seeing these requests
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['safety-team', 'admin']);

      // Only support team members can update safety requests
      // Updates include: status changes, assignment, admin notes
      allow update: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['safety-team', 'admin']);

      // NEVER allow deletion - compliance requirement
      // Safety requests must be retained for legal/compliance purposes
      allow delete: if false;
    }

    // ============================================
    // LEGAL PETITIONS COLLECTION (Story 3.6)
    // ============================================
    // CRITICAL: This is a legal pathway for parents excluded from family monitoring.
    // These rules ensure legal petitions are NEVER visible to family members.
    //
    // Security invariants:
    // 1. Any authenticated user can create a petition (petitioning for access)
    // 2. Only safety-team or admin can read/update
    // 3. NEVER delete - compliance requirement
    // 4. NEVER linked to family audit trail
    // 5. Collection NOT accessible via family-scoped queries
    // 6. Petitioner can only submit petition, not read/update (status check via Cloud Function)
    // ============================================

    match /legalPetitions/{petitionId} {
      // Any authenticated user can create a legal petition
      // This allows parents to petition for access even without family membership
      // Validates required fields are present
      allow create: if request.auth != null &&
        request.resource.data.id == petitionId &&
        request.resource.data.petitionerName is string &&
        request.resource.data.petitionerName.size() >= 1 &&
        request.resource.data.petitionerEmail is string &&
        request.resource.data.petitionerEmail.matches('^[^@]+@[^@]+\\.[^@]+$') &&
        request.resource.data.childName is string &&
        request.resource.data.childName.size() >= 1 &&
        request.resource.data.claimedRelationship in ['parent', 'legal-guardian'] &&
        request.resource.data.status == 'submitted' &&
        request.resource.data.referenceNumber is string &&
        request.resource.data.referenceNumber.matches('^LP-[0-9]{8}-[A-Z0-9]{5}$') &&
        request.resource.data.documents is list &&
        request.resource.data.documents.size() <= 5 &&
        request.resource.data.internalNotes is list &&
        request.resource.data.internalNotes.size() == 0;  // No internal notes on creation

      // Only support team members can read legal petitions
      // This prevents family members from ever seeing these petitions
      // Petitioners check their status via Cloud Function with reference number + email
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['safety-team', 'admin']);

      // Only support team members can update legal petitions
      // Updates include: status changes, assignment, target family ID, internal notes
      // Status must be valid: submitted, reviewing, pending-more-info, verified, denied
      allow update: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['safety-team', 'admin']) &&
        // Cannot change immutable fields
        request.resource.data.id == resource.data.id &&
        request.resource.data.referenceNumber == resource.data.referenceNumber &&
        request.resource.data.petitionerName == resource.data.petitionerName &&
        request.resource.data.petitionerEmail == resource.data.petitionerEmail &&
        request.resource.data.childName == resource.data.childName &&
        request.resource.data.childDOB == resource.data.childDOB &&
        request.resource.data.claimedRelationship == resource.data.claimedRelationship &&
        request.resource.data.message == resource.data.message &&
        request.resource.data.submittedAt == resource.data.submittedAt &&
        // Status must be valid
        request.resource.data.status in ['submitted', 'reviewing', 'pending-more-info', 'verified', 'denied'];

      // NEVER allow deletion - compliance requirement
      // Legal petitions must be retained for legal/compliance purposes
      allow delete: if false;
    }

    // ============================================
    // ADMIN ROLES COLLECTION
    // ============================================
    // Stores admin/support team role assignments
    // Only readable by the user themselves or other admins

    match /adminRoles/{userId} {
      // Users can read their own role document
      allow read: if request.auth != null && request.auth.uid == userId;

      // Only admins can read other users' roles
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['admin']);

      // Only admins can create/update/delete role assignments
      allow write: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['admin']);
    }

    // ============================================
    // USERS COLLECTION (Story 1.2, updated Story 2.1)
    // ============================================
    // Stores user profile data created on first sign-in
    //
    // Security invariants:
    // 1. Users can only read/write their own profile document
    // 2. uid must match the authenticated user's uid
    // 3. Required fields: uid, email, createdAt, lastLoginAt
    // 4. createdAt cannot be modified after creation
    // 5. familyId and role can only be set during family creation via transaction
    // 6. familyId cannot be changed once set (prevents family hopping)
    // 7. role can only be changed by guardians with full permissions
    // ============================================

    match /users/{userId} {
      // Users can read their own profile
      allow read: if request.auth != null && request.auth.uid == userId;

      // Users can create their own profile document
      // Validates: uid matches, required fields present, types are correct
      // familyId and role must NOT be set during user creation (only via family creation)
      allow create: if request.auth != null &&
        request.auth.uid == userId &&
        request.resource.data.uid == userId &&
        request.resource.data.keys().hasAll(['uid', 'email', 'createdAt', 'lastLoginAt']) &&
        request.resource.data.uid is string &&
        request.resource.data.email is string &&
        request.resource.data.email.matches('^[^@]+@[^@]+\\.[^@]+$') &&
        !('familyId' in request.resource.data) &&
        !('role' in request.resource.data);

      // Users can update their own profile
      // Validates: uid cannot change, createdAt cannot change
      // familyId can only be set ONCE (when null -> value), never changed after
      // role can only be set when familyId is being set for the first time
      allow update: if request.auth != null &&
        request.auth.uid == userId &&
        request.resource.data.uid == resource.data.uid &&
        request.resource.data.createdAt == resource.data.createdAt &&
        // familyId validation: can only be set once, never removed or changed
        (
          // Case 1: familyId unchanged (not in update or same value)
          (!('familyId' in request.resource.data) && !('familyId' in resource.data)) ||
          (request.resource.data.familyId == resource.data.familyId) ||
          // Case 2: familyId being set for first time (null/missing -> value)
          (!('familyId' in resource.data) && 'familyId' in request.resource.data &&
           request.resource.data.familyId is string && request.resource.data.familyId.size() > 0)
        ) &&
        // role validation: can only be set when familyId is being set
        // and must be 'guardian' when creating a family
        (
          // Case 1: role unchanged
          (!('role' in request.resource.data) && !('role' in resource.data)) ||
          (request.resource.data.role == resource.data.role) ||
          // Case 2: role being set for first time (only valid with familyId, must be 'guardian')
          (!('role' in resource.data) && 'role' in request.resource.data &&
           !('familyId' in resource.data) && 'familyId' in request.resource.data &&
           request.resource.data.role == 'guardian')
        );

      // Users cannot delete their own profile
      // Deletion should go through proper account deletion flow
      allow delete: if false;
    }

    // ============================================
    // FAMILIES COLLECTION (Story 2.1, Story 2.7)
    // ============================================
    // Stores family documents with guardian and child references
    //
    // Security invariants:
    // 1. Only authenticated users can create families
    // 2. Creator must set themselves as primary guardian
    // 3. Only guardians with 'full' permissions can read/update family
    // 4. Families cannot be deleted (for audit purposes)
    // 5. Guardian array must have valid structure (prevents injection)
    // 6. Maximum 10 guardians per family (prevents abuse)
    //
    // DISSOLUTION (Story 2.7):
    // - dissolution field stores the dissolution request state
    // - dissolution.status must be: 'pending_acknowledgment', 'cooling_period', 'cancelled', 'completed'
    // - dissolution.dataHandlingOption must be: 'delete_all', 'export_first', 'retain_90_days'
    // - Any guardian can initiate, acknowledge, or cancel dissolution
    // - Audit entries are created in auditLog subcollection
    // ============================================

    match /families/{familyId} {
      // Helper function to check if user is a guardian in this family
      // Uses explicit index checking to prevent array manipulation attacks
      function isGuardian() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid) ||
            (guardians.size() >= 2 && guardians[1].uid == uid) ||
            (guardians.size() >= 3 && guardians[2].uid == uid) ||
            (guardians.size() >= 4 && guardians[3].uid == uid) ||
            (guardians.size() >= 5 && guardians[4].uid == uid) ||
            (guardians.size() >= 6 && guardians[5].uid == uid) ||
            (guardians.size() >= 7 && guardians[6].uid == uid) ||
            (guardians.size() >= 8 && guardians[7].uid == uid) ||
            (guardians.size() >= 9 && guardians[8].uid == uid) ||
            (guardians.size() >= 10 && guardians[9].uid == uid)
          );
      }

      // Helper function to check if user has full permissions
      // Uses explicit index checking for security
      function hasFullPermissions() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Helper function to validate guardian structure
      function isValidGuardian(guardian) {
        return guardian.keys().hasAll(['uid', 'role', 'permissions', 'joinedAt']) &&
          guardian.uid is string &&
          guardian.uid.size() > 0 &&
          guardian.role in ['primary', 'co-parent'] &&
          guardian.permissions in ['full', 'readonly'];
      }

      // Helper function to check if a guardian is ONLY updating the dissolution field (Story 2.7)
      // This allows any guardian (not just full permissions) to acknowledge or cancel dissolution
      // but prevents them from modifying other family data without full permissions
      function isGuardianUpdatingDissolutionOnly() {
        return isGuardian() &&
          // All other fields must remain unchanged
          request.resource.data.guardians == resource.data.guardians &&
          request.resource.data.children == resource.data.children &&
          request.resource.data.name == resource.data.name &&
          // Only dissolution field can change
          (
            // Case 1: Adding dissolution field
            (!('dissolution' in resource.data) && 'dissolution' in request.resource.data) ||
            // Case 2: Updating existing dissolution field
            ('dissolution' in resource.data && 'dissolution' in request.resource.data &&
             request.resource.data.dissolution != resource.data.dissolution) ||
            // Case 3: Removing dissolution field (after completion)
            ('dissolution' in resource.data && !('dissolution' in request.resource.data))
          );
      }

      // Helper function to check if user is accepting an invitation (Story 3.3)
      // This allows a new user to add themselves as a guardian through invitation acceptance
      // CRITICAL: Validates that only ONE guardian is being added (the authenticated user)
      // Token verification happens server-side via verifyInvitationToken()
      function isAcceptingInvitation() {
        let uid = request.auth.uid;
        let oldGuardians = resource.data.guardians;
        let newGuardians = request.resource.data.guardians;

        return request.auth != null &&
          // Must be adding exactly 1 guardian
          newGuardians.size() == oldGuardians.size() + 1 &&
          // All other fields unchanged (except guardians)
          request.resource.data.children == resource.data.children &&
          request.resource.data.name == resource.data.name &&
          request.resource.data.createdBy == resource.data.createdBy &&
          request.resource.data.createdAt == resource.data.createdAt &&
          // The new guardian must be the authenticated user (prevents adding arbitrary users)
          (
            (newGuardians.size() == 2 && newGuardians[1].uid == uid) ||
            (newGuardians.size() == 3 && newGuardians[2].uid == uid) ||
            (newGuardians.size() == 4 && newGuardians[3].uid == uid) ||
            (newGuardians.size() == 5 && newGuardians[4].uid == uid) ||
            (newGuardians.size() == 6 && newGuardians[5].uid == uid) ||
            (newGuardians.size() == 7 && newGuardians[6].uid == uid) ||
            (newGuardians.size() == 8 && newGuardians[7].uid == uid) ||
            (newGuardians.size() == 9 && newGuardians[8].uid == uid) ||
            (newGuardians.size() == 10 && newGuardians[9].uid == uid)
          );
      }

      // Users can create a family if:
      // - They are authenticated
      // - They set themselves as the creator
      // - They set themselves as the ONLY guardian with 'primary' role
      // - Guardian has valid structure
      // - Children array starts empty
      // NOTE: Exactly 1 guardian on creation prevents bypassing invitation flow
      allow create: if request.auth != null &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() == 1 &&  // Exactly 1 guardian on creation
        request.resource.data.guardians[0].uid == request.auth.uid &&
        request.resource.data.guardians[0].role == 'primary' &&
        request.resource.data.guardians[0].permissions == 'full' &&
        isValidGuardian(request.resource.data.guardians[0]) &&
        request.resource.data.children is list &&
        request.resource.data.children.size() == 0;  // Must start with no children

      // Only guardians can read their family
      // Note: For invitation acceptance, the accepting user can't read before becoming a guardian
      // The invitation preview provides the family name - full family access requires guardian status
      allow read: if isGuardian();

      // Only guardians with full permissions can update
      // Additional validation: cannot remove all guardians, cannot exceed 10
      // NOTE: Any guardian (not just full permissions) can update dissolution field
      // NOTE: Authenticated users accepting invitations can add themselves as guardian (Story 3.3)
      allow update: if (hasFullPermissions() || isGuardianUpdatingDissolutionOnly() || isAcceptingInvitation()) &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() >= 1 &&
        request.resource.data.guardians.size() <= 10 &&
        request.resource.data.children is list &&
        // Prevent changing createdBy (immutable)
        request.resource.data.createdBy == resource.data.createdBy &&
        // Prevent changing createdAt (immutable)
        request.resource.data.createdAt == resource.data.createdAt &&
        // Dissolution field validation (Story 2.7)
        (
          // Case 1: No dissolution field
          !('dissolution' in request.resource.data) ||
          // Case 2: Dissolution field is null (cleared after completion)
          request.resource.data.dissolution == null ||
          // Case 3: Dissolution field has valid status
          ('dissolution' in request.resource.data &&
           request.resource.data.dissolution != null &&
           request.resource.data.dissolution.status in ['pending_acknowledgment', 'cooling_period', 'cancelled', 'completed'] &&
           request.resource.data.dissolution.dataHandlingOption in ['delete_all', 'export_first', 'retain_90_days'])
        );

      // Families cannot be deleted (for audit purposes)
      allow delete: if false;

      // ============================================
      // FAMILY AUDIT LOG SUBCOLLECTION (Story 2.5, Story 3.3)
      // ============================================
      // Stores audit entries for family actions (child updates, guardian changes, etc.)
      //
      // Security invariants:
      // 1. Only guardians can read audit logs
      // 2. Guardians can create audit entries (via transaction)
      // 3. Authenticated users can create 'invitation_accepted' entries (Story 3.3)
      //    This allows the accepting user to log their acceptance
      // 4. Audit entries are immutable - no updates or deletes
      // 5. performedBy must match authenticated user
      // ============================================
      match /auditLog/{logId} {
        // Only guardians can read audit logs
        allow read: if isGuardian();

        // Guardians can create audit entries
        // Also: Authenticated users can create 'invitation_accepted' entries (Story 3.3)
        // Validates: performedBy matches authenticated user
        allow create: if request.auth != null &&
          request.resource.data.performedBy == request.auth.uid &&
          request.resource.data.id == logId &&
          request.resource.data.action is string &&
          request.resource.data.entityId is string &&
          request.resource.data.entityType is string &&
          // Must either be a guardian OR creating an invitation_accepted entry
          (isGuardian() || request.resource.data.action == 'invitation_accepted');

        // Audit entries are immutable - no updates
        allow update: if false;

        // Audit entries cannot be deleted
        allow delete: if false;
      }
    }

    // ============================================
    // CHILDREN COLLECTION (Story 2.2, Story 2.3, Story 2.5, Story 2.6)
    // ============================================
    // Stores child profile documents
    //
    // Security invariants:
    // 1. Only guardians can create children in their family
    // 2. Only guardians with 'full' permissions can read/update children
    // 3. Only guardians with 'full' permissions can delete children (Story 2.6)
    // 4. familyId must match the creator's family
    // 5. Maximum 10 guardians per child (same as family limit)
    // 6. Custody declaration can only be set/updated by guardians with full permissions
    // 7. Custody history can only grow, never shrink (audit trail)
    // 8. custodyDeclaration.type must be 'sole', 'shared', or 'complex'
    //
    // DELETION REQUIREMENTS (Story 2.6):
    // - Only guardians with 'full' permissions can delete children
    // - Deletion requires re-authentication (verified via token age on client)
    // - Audit log entry must be created BEFORE deletion (via batch write)
    // - Device documents must be deleted (via separate service call)
    // - Data deletion (screenshots, activity logs) via separate service
    // - childId removed from family's children array (via batch write)
    //
    // MONITORING GATE (Story 2.3, AC7 - Epic 9/12 enforcement):
    // - Device monitoring CANNOT be started until custody is declared
    // - Client-side check: canStartMonitoring(child) helper in contracts
    // - Server-side enforcement: devices collection rules will verify
    //   custodyDeclaration exists before allowing device enrollment
    // - This ensures custody arrangements are documented before monitoring begins
    // ============================================

    match /children/{childId} {
      // Helper function to check if user is a guardian for this child
      // Uses explicit index checking to prevent array manipulation attacks
      function isChildGuardian() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid) ||
            (guardians.size() >= 2 && guardians[1].uid == uid) ||
            (guardians.size() >= 3 && guardians[2].uid == uid) ||
            (guardians.size() >= 4 && guardians[3].uid == uid) ||
            (guardians.size() >= 5 && guardians[4].uid == uid) ||
            (guardians.size() >= 6 && guardians[5].uid == uid) ||
            (guardians.size() >= 7 && guardians[6].uid == uid) ||
            (guardians.size() >= 8 && guardians[7].uid == uid) ||
            (guardians.size() >= 9 && guardians[8].uid == uid) ||
            (guardians.size() >= 10 && guardians[9].uid == uid)
          );
      }

      // Helper function to check if user has full permissions on child
      // Uses explicit index checking for security
      function hasFullChildPermissions() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Helper function to check if user is a guardian in the target family
      // CRITICAL: This prevents cross-family child injection attacks
      // Uses explicit index checking for security (same pattern as isGuardian in families)
      function isGuardianInTargetFamily(familyId) {
        let familyDoc = get(/databases/$(database)/documents/families/$(familyId));
        let guardians = familyDoc.data.guardians;
        let uid = request.auth.uid;
        return familyDoc != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid) ||
            (guardians.size() >= 2 && guardians[1].uid == uid) ||
            (guardians.size() >= 3 && guardians[2].uid == uid) ||
            (guardians.size() >= 4 && guardians[3].uid == uid) ||
            (guardians.size() >= 5 && guardians[4].uid == uid) ||
            (guardians.size() >= 6 && guardians[5].uid == uid) ||
            (guardians.size() >= 7 && guardians[6].uid == uid) ||
            (guardians.size() >= 8 && guardians[7].uid == uid) ||
            (guardians.size() >= 9 && guardians[8].uid == uid) ||
            (guardians.size() >= 10 && guardians[9].uid == uid)
          );
      }

      // Helper function to check if user is accepting invitation for this child (Story 3.3)
      // This allows a new co-parent to add themselves as guardian through invitation acceptance
      // CRITICAL: Validates that only ONE guardian is being added (the authenticated user)
      function isAcceptingInvitationForChild() {
        let uid = request.auth.uid;
        let oldGuardians = resource.data.guardians;
        let newGuardians = request.resource.data.guardians;

        return request.auth != null &&
          // Must be adding exactly 1 guardian
          newGuardians.size() == oldGuardians.size() + 1 &&
          // All other fields unchanged (except guardians)
          request.resource.data.firstName == resource.data.firstName &&
          request.resource.data.createdBy == resource.data.createdBy &&
          request.resource.data.createdAt == resource.data.createdAt &&
          request.resource.data.familyId == resource.data.familyId &&
          // The new guardian must be the authenticated user (prevents adding arbitrary users)
          (
            (newGuardians.size() == 2 && newGuardians[1].uid == uid) ||
            (newGuardians.size() == 3 && newGuardians[2].uid == uid) ||
            (newGuardians.size() == 4 && newGuardians[3].uid == uid) ||
            (newGuardians.size() == 5 && newGuardians[4].uid == uid) ||
            (newGuardians.size() == 6 && newGuardians[5].uid == uid) ||
            (newGuardians.size() == 7 && newGuardians[6].uid == uid) ||
            (newGuardians.size() == 8 && newGuardians[7].uid == uid) ||
            (newGuardians.size() == 9 && newGuardians[8].uid == uid) ||
            (newGuardians.size() == 10 && newGuardians[9].uid == uid)
          );
      }

      // Users can create children if:
      // - They are authenticated
      // - They set themselves as the creator
      // - They are the only guardian on creation (exactly 1)
      // - They have 'full' permissions on the child
      // - familyId references an existing family
      // - CRITICAL: Creator must be a guardian in that family (prevents cross-family injection)
      // - Required fields are present
      allow create: if request.auth != null &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() == 1 &&
        request.resource.data.guardians[0].uid == request.auth.uid &&
        request.resource.data.guardians[0].permissions == 'full' &&
        request.resource.data.familyId is string &&
        request.resource.data.familyId.size() > 0 &&
        request.resource.data.firstName is string &&
        request.resource.data.firstName.size() >= 1 &&
        request.resource.data.firstName.size() <= 50 &&
        // Verify the family exists AND user is a guardian in that family
        exists(/databases/$(database)/documents/families/$(request.resource.data.familyId)) &&
        isGuardianInTargetFamily(request.resource.data.familyId);

      // Only guardians can read children
      allow read: if isChildGuardian();

      // Only guardians with full permissions can update
      // Also: Authenticated users accepting invitations can add themselves as guardian (Story 3.3)
      // Cannot change: createdBy, createdAt, familyId (immutable)
      // Custody validation: history can only grow, type must be valid
      allow update: if (hasFullChildPermissions() || isAcceptingInvitationForChild()) &&
        request.resource.data.createdBy == resource.data.createdBy &&
        request.resource.data.createdAt == resource.data.createdAt &&
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() >= 1 &&
        request.resource.data.guardians.size() <= 10 &&
        // Custody history validation: can only grow, never shrink (audit trail)
        (
          // Case 1: No custody history in either old or new data
          (!('custodyHistory' in resource.data) && !('custodyHistory' in request.resource.data)) ||
          // Case 2: Adding custody history for first time
          (!('custodyHistory' in resource.data) && 'custodyHistory' in request.resource.data &&
           request.resource.data.custodyHistory is list) ||
          // Case 3: Custody history exists and can only grow
          ('custodyHistory' in resource.data && 'custodyHistory' in request.resource.data &&
           request.resource.data.custodyHistory is list &&
           request.resource.data.custodyHistory.size() >= resource.data.custodyHistory.size())
        ) &&
        // Custody declaration type validation: must be 'sole', 'shared', or 'complex'
        (
          // Case 1: No custody declaration
          !('custodyDeclaration' in request.resource.data) ||
          // Case 2: Custody declaration is null (cleared)
          request.resource.data.custodyDeclaration == null ||
          // Case 3: Custody declaration has valid type
          ('custodyDeclaration' in request.resource.data &&
           request.resource.data.custodyDeclaration != null &&
           request.resource.data.custodyDeclaration.type in ['sole', 'shared', 'complex'])
        );

      // Only guardians with full permissions can delete children (Story 2.6)
      // Re-authentication and audit logging are enforced client-side via:
      // - useReauthentication hook verifies recent auth token
      // - removeChildFromFamily creates audit entry BEFORE deletion
      // - Device documents are deleted via separate service call
      allow delete: if hasFullChildPermissions();

      // ============================================
      // VIEW AUDIT LOG SUBCOLLECTION (Story 3A.1: Data Symmetry)
      // ============================================
      // Stores audit entries for when guardians view child data.
      // CRITICAL: Implements data symmetry enforcement - both co-parents
      // must see identical audit trails. This ensures transparency
      // in shared custody situations.
      //
      // Security invariants:
      // 1. ALL guardians can read the full audit trail (symmetry requirement)
      // 2. Guardians can only create entries for themselves (viewedBy = auth.uid)
      // 3. Audit entries are immutable - no updates or deletes
      // 4. Both parents see identical data with identical timestamps
      // ============================================
      match /viewAuditLog/{logId} {
        // ALL guardians can read the full audit trail
        // SYMMETRY ENFORCEMENT: Both co-parents must see identical viewing history
        // This prevents information asymmetry in shared custody situations
        allow read: if isChildGuardian();

        // Guardians can create audit entries for their own views
        // Validates: viewedBy matches authenticated user
        allow create: if isChildGuardian() &&
          request.resource.data.viewedBy == request.auth.uid &&
          request.resource.data.id == logId &&
          request.resource.data.childId == childId &&
          request.resource.data.dataType is string &&
          request.resource.data.dataType.size() > 0;

        // Audit entries are immutable - no updates
        // This ensures the audit trail cannot be tampered with
        allow update: if false;

        // Audit entries cannot be deleted
        // Compliance requirement for custody situations
        allow delete: if false;
      }

      // ============================================
      // SAFETY SETTINGS PROPOSALS SUBCOLLECTION (Story 3A.2)
      // ============================================
      // Stores proposals for changing safety-related settings in shared custody families.
      // CRITICAL: In shared custody, safety setting changes require dual-approval
      // to prevent one parent from unilaterally weakening protections.
      //
      // Security invariants:
      // 1. ALL guardians can read proposals (transparency for both co-parents)
      // 2. Guardians can create proposals for their children
      // 3. Only Cloud Functions can update proposals (status transitions)
      // 4. Proposals cannot be deleted (immutable audit trail)
      // 5. Emergency safety increases auto-apply but can be disputed
      // ============================================
      match /safetySettingsProposals/{proposalId} {
        // ALL guardians can read proposals
        // Both co-parents must see pending proposals to respond
        allow read: if isChildGuardian();

        // Guardians can create proposals for settings changes
        // Validates: proposedBy matches authenticated user
        allow create: if isChildGuardian() &&
          request.resource.data.proposedBy == request.auth.uid &&
          request.resource.data.id == proposalId &&
          request.resource.data.childId == childId &&
          request.resource.data.settingType is string &&
          request.resource.data.status in ['pending', 'auto_applied'];

        // Only Cloud Functions can update proposals
        // Status transitions (approve/decline/dispute) go through functions
        // This ensures proper validation and side effects
        allow update: if false;

        // Proposals cannot be deleted - compliance requirement
        allow delete: if false;
      }
    }

    // ============================================
    // DEVICES COLLECTION (Epic 9/12 - Future Implementation)
    // ============================================
    // PLACEHOLDER: Device enrollment and monitoring data
    //
    // CRITICAL SECURITY REQUIREMENT (Story 2.3, AC7):
    // Device enrollment MUST verify that the child has a custody declaration
    // before allowing monitoring to begin. This ensures:
    // 1. Custody arrangements are documented before any monitoring
    // 2. Shared custody families have appropriate safeguards in place
    // 3. Legal/compliance requirements are met for child monitoring
    //
    // Future rules must check:
    // - User is guardian with 'full' permissions on the child
    // - Child document has custodyDeclaration != null
    // - If custodyDeclaration.type == 'shared', Epic 3A safeguards are applied
    //
    // Example rule pattern (to be implemented in Epic 9/12):
    // allow create: if hasFullChildPermissions(childId) &&
    //   get(/databases/$(database)/documents/children/$(childId)).data.custodyDeclaration != null;
    // ============================================

    match /devices/{deviceId} {
      // Helper function to check if user has full permissions for the device's child
      // Requires fetching the child document to verify guardian permissions
      function hasFullChildPermissionsForDevice() {
        let childId = resource.data.childId;
        let childDoc = get(/databases/$(database)/documents/children/$(childId));
        let guardians = childDoc.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          childDoc != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Guardians can read devices for their children
      allow read: if hasFullChildPermissionsForDevice();

      // Device creation: Full implementation in Epic 9/12
      // For now, allow creation if user has full permissions for the child
      // and the child has a custody declaration (monitoring gate)
      allow create: if request.auth != null &&
        request.resource.data.childId is string &&
        request.resource.data.familyId is string &&
        exists(/databases/$(database)/documents/children/$(request.resource.data.childId)) &&
        get(/databases/$(database)/documents/children/$(request.resource.data.childId)).data.custodyDeclaration != null;

      // Device updates: Only guardians with full permissions
      allow update: if hasFullChildPermissionsForDevice();

      // Device deletion: Only guardians with full permissions (Story 2.6)
      // Required for child removal flow - unenroll devices before child deletion
      allow delete: if hasFullChildPermissionsForDevice();
    }

    // ============================================
    // SEALED AUDITS COLLECTION (Story 2.8)
    // ============================================
    // CRITICAL LIFE-SAFETY FEATURE: Sealed audit trail for self-removal
    //
    // These entries are NEVER visible to family members.
    // Only support agents with safety-team role can read.
    // Used for survivor escape tracking without exposing to abusers.
    //
    // Security invariants:
    // 1. Authenticated users can create entries (for self-removal)
    // 2. Only safety-team or admin can read
    // 3. NEVER delete or update - compliance requirement
    // 4. NEVER linked to family audit trail
    // ============================================

    match /sealed_audits/{auditId} {
      // Authenticated users can create sealed audit entries
      // This allows guardians to log their own self-removal action
      // without needing admin privileges
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.id == auditId &&
        request.resource.data.action in ['guardian_self_removed', 'safety_escape_initiated'] &&
        request.resource.data.familyId is string &&
        request.resource.data.familyId.size() > 0;

      // Only safety-team or admin can read sealed audits
      // This prevents abusers from seeing that someone left
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['safety-team', 'admin']);

      // NEVER allow updates - sealed audit entries are immutable
      allow update: if false;

      // NEVER allow deletion - compliance requirement
      allow delete: if false;
    }

    // ============================================
    // INVITATIONS COLLECTION (Story 3.1)
    // ============================================
    // Stores co-parent invitation documents for family joining
    //
    // Security invariants:
    // 1. Only guardians with 'full' permissions can create invitations
    // 2. Only guardians can read their family's invitations
    // 3. Only guardians with 'full' permissions can revoke invitations
    // 4. NEVER delete - compliance requirement
    // 5. Token is hashed (SHA-256) - never stored in plaintext
    // 6. Only one pending invitation per family at a time
    // 7. Public query by tokenHash allowed for invitation acceptance
    //
    // Invitation acceptance (Story 3.2) will use Cloud Function to:
    // - Verify token hash matches
    // - Check invitation hasn't expired
    // - Add accepting user to family guardians array
    // - Update invitation status to 'accepted'
    // ============================================

    match /invitations/{invitationId} {
      // Helper function to check if user is a guardian in the invitation's family
      // with full permissions
      function hasFullPermissionsInInvitationFamily() {
        let familyId = resource.data.familyId;
        let familyDoc = get(/databases/$(database)/documents/families/$(familyId));
        let guardians = familyDoc.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          familyDoc != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Helper function to check if user is a guardian in the invitation's family
      function isGuardianInInvitationFamily() {
        let familyId = resource.data.familyId;
        let familyDoc = get(/databases/$(database)/documents/families/$(familyId));
        let guardians = familyDoc.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          familyDoc != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid) ||
            (guardians.size() >= 2 && guardians[1].uid == uid) ||
            (guardians.size() >= 3 && guardians[2].uid == uid) ||
            (guardians.size() >= 4 && guardians[3].uid == uid) ||
            (guardians.size() >= 5 && guardians[4].uid == uid) ||
            (guardians.size() >= 6 && guardians[5].uid == uid) ||
            (guardians.size() >= 7 && guardians[6].uid == uid) ||
            (guardians.size() >= 8 && guardians[7].uid == uid) ||
            (guardians.size() >= 9 && guardians[8].uid == uid) ||
            (guardians.size() >= 10 && guardians[9].uid == uid)
          );
      }

      // Helper function for create - check if user has full permissions in target family
      function hasFullPermissionsInTargetFamily(familyId) {
        let familyDoc = get(/databases/$(database)/documents/families/$(familyId));
        let guardians = familyDoc.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          familyDoc != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Create invitation:
      // - User must be authenticated
      // - User must be a guardian with full permissions in the family
      // - invitedBy must match authenticated user
      // - Required fields: id, familyId, familyName, invitedBy, invitedByName, tokenHash, status, createdAt, expiresAt
      // - Status must be 'pending' on creation
      // - tokenHash must be a string (SHA-256 hash)
      allow create: if request.auth != null &&
        request.resource.data.id == invitationId &&
        request.resource.data.familyId is string &&
        request.resource.data.familyId.size() > 0 &&
        request.resource.data.familyName is string &&
        request.resource.data.invitedBy == request.auth.uid &&
        request.resource.data.invitedByName is string &&
        request.resource.data.tokenHash is string &&
        request.resource.data.tokenHash.size() > 0 &&
        request.resource.data.status == 'pending' &&
        request.resource.data.acceptedAt == null &&
        request.resource.data.acceptedBy == null &&
        exists(/databases/$(database)/documents/families/$(request.resource.data.familyId)) &&
        hasFullPermissionsInTargetFamily(request.resource.data.familyId);

      // Read invitation:
      // - Guardians can read their family's invitations
      // - Any authenticated user can read invitation by ID for acceptance flow (Story 3.3)
      //   This allows the accepting user to see the invitation preview before accepting
      // Note: Sensitive data (like full token) is never stored - only hash
      allow read: if isGuardianInInvitationFamily() || request.auth != null;

      // Update invitation:
      // - Only guardians with full permissions can revoke (status -> 'revoked')
      // - Any authenticated user can accept (status -> 'accepted') with acceptedAt/acceptedBy (Story 3.3)
      //   Token verification is done server-side via verifyInvitationToken() with timing-safe comparison
      // - Cannot change: id, familyId, familyName, invitedBy, invitedByName, tokenHash, createdAt
      // - status can only go: pending -> revoked, pending -> accepted
      allow update: if request.auth != null &&
        request.resource.data.id == resource.data.id &&
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.familyName == resource.data.familyName &&
        request.resource.data.invitedBy == resource.data.invitedBy &&
        request.resource.data.invitedByName == resource.data.invitedByName &&
        request.resource.data.tokenHash == resource.data.tokenHash &&
        request.resource.data.createdAt == resource.data.createdAt &&
        request.resource.data.expiresAt == resource.data.expiresAt &&
        // Status transition validation
        (
          // Revoke: pending -> revoked (by guardian with full permissions only)
          (resource.data.status == 'pending' && request.resource.data.status == 'revoked' && hasFullPermissionsInInvitationFamily()) ||
          // Accept: pending -> accepted (by any authenticated user, token verified server-side)
          // CRITICAL: acceptedBy must match authenticated user, acceptedAt must be set
          (resource.data.status == 'pending' && request.resource.data.status == 'accepted' &&
           request.resource.data.acceptedBy == request.auth.uid &&
           request.resource.data.acceptedAt != null) ||
          // Status unchanged
          (request.resource.data.status == resource.data.status)
        );

      // NEVER allow deletion - compliance requirement
      // Invitations are kept for audit purposes
      allow delete: if false;
    }

    // ============================================
    // MAIL COLLECTION (Story 3.2: Invitation Email Delivery)
    // ============================================
    // Used by Firebase Trigger Email extension to send emails
    //
    // Security invariants:
    // 1. Only authenticated users can create mail documents
    // 2. User must be guardian with full permissions in the invitation's family
    // 3. User must be the one who created the invitation (invitedBy)
    // 4. Invitation must be pending (not expired/revoked/accepted)
    // 5. Subject must be for invitation emails (prevents abuse)
    // 6. No read/update/delete allowed (extension handles processing)
    //
    // Note: Rate limiting is enforced in the service layer (max 3 emails/hour)
    // because Firestore rules cannot atomically read and increment counters
    // ============================================

    match /mail/{mailId} {
      // Helper function to verify user can send invitation email
      // Checks: user is the inviter and has full permissions in the family
      function canSendInvitationEmail(invitationId) {
        let invitation = get(/databases/$(database)/documents/invitations/$(invitationId));
        let familyId = invitation.data.familyId;
        let familyDoc = get(/databases/$(database)/documents/families/$(familyId));
        let guardians = familyDoc.data.guardians;
        let uid = request.auth.uid;

        return request.auth != null &&
          invitation != null &&
          familyDoc != null &&
          // User must be the one who created the invitation
          invitation.data.invitedBy == uid &&
          // Invitation must be pending (not expired/revoked/accepted)
          invitation.data.status == 'pending' &&
          // User must be guardian with full permissions
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Allow mail creation only for invitation emails
      // Validates structure and authorization
      allow create: if request.auth != null &&
        // Must have valid email structure
        request.resource.data.to is string &&
        request.resource.data.to.matches('^[^@]+@[^@]+\\.[^@]+$') &&
        request.resource.data.message is map &&
        request.resource.data.message.subject is string &&
        request.resource.data.message.html is string &&
        request.resource.data.message.text is string &&
        // Subject must be for invitation (prevents abuse for other emails)
        request.resource.data.message.subject.matches('.*Join .* on fledgely') &&
        // Must have valid invitationId for authorization check
        request.resource.data.invitationId is string &&
        canSendInvitationEmail(request.resource.data.invitationId);

      // No read access (extension processes emails)
      allow read: if false;

      // No updates (mail documents are immutable)
      allow update: if false;

      // No deletes (mail processing is handled by extension)
      allow delete: if false;
    }

    // ============================================
    // ADMIN AUDIT LOG COLLECTION
    // ============================================
    // Separate audit log for admin/support actions
    // NEVER linked to family audit trails

    match /adminAuditLog/{logId} {
      // Only admins can read audit logs
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['admin']);

      // System can write audit entries (via Cloud Functions)
      // Direct client writes are not allowed
      allow write: if false;
    }
  }
}
