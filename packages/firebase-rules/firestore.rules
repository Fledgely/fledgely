rules_version = '2';

/**
 * Fledgely Firestore Security Rules
 *
 * Default: Deny all access
 * Individual rules will be added as features are implemented.
 *
 * Security principles:
 * - Deny by default
 * - Least privilege
 * - Users can only access their own data
 * - Guardians can access children they're authorized for
 * - No data leakage across families
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // User profiles: users can only read/write their own document
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Family documents: only guardians can access their family
    match /families/{familyId} {
      // Helper function to check if user is a guardian of this family
      function isGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardians[].uid;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardians[].uid;
      }

      // Read: only guardians can read family data
      allow read: if isGuardian();

      // Create: authenticated user can create family if they're adding themselves as guardian
      allow create: if request.auth != null && isCreatingAsGuardian();

      // Update: only existing guardians can update family
      // Story 3.4 AC6: Prevent guardian removal in co-managed families
      // Guardians array can only grow or stay same size - no removals allowed
      allow update: if isGuardian() &&
        request.resource.data.guardians.size() >= resource.data.guardians.size();

      // Delete: only guardians can delete their family (single-guardian only)
      // Multi-guardian families require support intervention
      allow delete: if isGuardian() && resource.data.guardians.size() == 1;
    }

    // Child documents: guardians can access children in their family
    //
    // EPIC 3A DATA SYMMETRY PRINCIPLE (Story 3A.1):
    // Both co-parents in shared custody families MUST have IDENTICAL access.
    // All guardians in the guardians[] array have equal read permissions.
    // No data filtering, delay, or modification based on which guardian views.
    // This prevents information asymmetry in custody situations.
    //
    match /children/{childId} {
      // Helper function to check if user is a guardian of this child
      // DATA SYMMETRY: All guardians in guardians[] have identical access
      function isChildGuardian() {
        return request.auth != null &&
          request.auth.uid in resource.data.guardians[].uid;
      }

      // Helper function to check if user is creating themselves as guardian
      function isCreatingAsGuardian() {
        return request.auth != null &&
          request.auth.uid in request.resource.data.guardians[].uid;
      }

      // Helper function to verify user is guardian of the family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth.uid in family.data.guardians[].uid;
      }

      // Read: only child guardians can read
      // DATA SYMMETRY: Both co-parents see identical data simultaneously
      allow read: if isChildGuardian();

      // Create: authenticated user who is guardian of the family
      allow create: if request.auth != null &&
        isCreatingAsGuardian() && isFamilyGuardian();

      // Update: only existing guardians can update
      allow update: if isChildGuardian();

      // Delete: only existing guardians can delete
      allow delete: if isChildGuardian();
    }

    // Invitation documents: for co-parent invitations
    match /invitations/{invitationId} {
      // Helper to check if user is the inviter
      function isInviter() {
        return request.auth != null &&
          request.auth.uid == resource.data.inviterUid;
      }

      // Helper to check if user is a guardian of the invitation's family
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Read: Allow public read for pending invitations (Story 3.3 - AC1)
      // This allows invitees to see invitation details BEFORE signing in.
      // Security: Token is unguessable UUID, and only pending invitations are readable.
      // Authenticated users can read any invitation (for guardians managing invitations).
      allow read: if resource.data.status == 'pending' || request.auth != null;

      // Create: authenticated users can create if they're set as inviter
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.inviterUid;

      // Update: only inviter can update (for revoking, marking expired)
      allow update: if isInviter();

      // Delete: not allowed (use status: revoked instead)
      allow delete: if false;
    }

    // Audit logs: append-only logs for data viewing transparency
    //
    // Story 3A.1: Data Symmetry Enforcement - AC3
    // Records when guardians view child or family data.
    // Story 3A.5: Screenshot Viewing Rate Alert uses this data.
    //
    // AC5 (Future): Access Revocation Symmetry
    // When one parent's access is revoked (Story 3.6 legal petition),
    // audit logs may become inaccessible to both until resolved.
    // This ensures no information asymmetry during dispute resolution.
    //
    match /auditLogs/{logId} {
      // Helper: Check if user is a guardian of the family in the audit log
      function isFamilyGuardianForAudit() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Helper: Check if user is guardian of family for existing audit log
      function canReadFamilyAudit() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Read: Family guardians can read audit logs for their family
      // DATA SYMMETRY: Both co-parents can see all viewing activity
      allow read: if canReadFamilyAudit();

      // Create: Guardians can only log their own views (prevent spoofing)
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.viewerUid &&
        isFamilyGuardianForAudit();

      // Update/Delete: Not allowed (audit trail immutability)
      // Audit logs are append-only for compliance and trust
      allow update, delete: if false;
    }

    // Safety setting change proposals: two-parent approval workflow
    //
    // Story 3A.2: Safety Settings Two-Parent Approval
    // In shared custody families, safety-related setting changes require
    // both guardians to approve before taking effect.
    //
    // Key rules:
    // - Only guardians can propose changes for their family
    // - Only the OTHER guardian (not the proposer) can approve/decline
    // - Proposals cannot be self-approved (prevents single-parent override)
    // - Approved/declined/expired changes are immutable (audit trail)
    //
    match /safetySettingChanges/{changeId} {
      // Helper: Check if user is a guardian of the family for new proposals
      function isFamilyGuardianForCreate() {
        let family = get(/databases/$(database)/documents/families/$(request.resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Helper: Check if user is a guardian of the family for existing changes
      function isFamilyGuardian() {
        let family = get(/databases/$(database)/documents/families/$(resource.data.familyId));
        return request.auth != null &&
          request.auth.uid in family.data.guardians[].uid;
      }

      // Helper: Check if user is the OTHER guardian (not the proposer)
      // CRITICAL: This prevents self-approval
      function isOtherGuardian() {
        return isFamilyGuardian() &&
          request.auth.uid != resource.data.proposedByUid;
      }

      // Read: Family guardians can read all proposals for their family
      // DATA SYMMETRY: Both co-parents see all pending, approved, and declined changes
      allow read: if isFamilyGuardian();

      // Create: Guardians can propose changes for their family
      // Must set themselves as proposer (prevent impersonation)
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.proposedByUid &&
        isFamilyGuardianForCreate() &&
        request.resource.data.status == 'pending_approval';

      // Update: Only the OTHER guardian can approve/decline
      // - Must be pending_approval to be updated
      // - Can only transition to approved or declined (not back to pending)
      // - Cannot modify proposal details, only status and resolution fields
      allow update: if isOtherGuardian() &&
        resource.data.status == 'pending_approval' &&
        request.resource.data.status in ['approved', 'declined'] &&
        // Preserve original proposal data (immutability of proposal content)
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.settingType == resource.data.settingType &&
        request.resource.data.currentValue == resource.data.currentValue &&
        request.resource.data.proposedValue == resource.data.proposedValue &&
        request.resource.data.proposedByUid == resource.data.proposedByUid;

      // Delete: Not allowed (keep audit trail)
      // Expired proposals remain for historical reference
      allow delete: if false;
    }

    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
