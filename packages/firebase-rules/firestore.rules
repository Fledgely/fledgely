rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // SAFETY REQUESTS COLLECTION
    // ============================================
    // CRITICAL: This is a life-safety feature for victims escaping abuse.
    // These rules ensure safety requests are NEVER visible to family members.
    //
    // Security invariants:
    // 1. Anyone can create (supports anonymous submissions from non-authenticated users)
    // 2. Only safety-team or admin can read/update
    // 3. NEVER delete - compliance requirement
    // 4. NEVER linked to family audit trail
    // ============================================

    match /safetyRequests/{requestId} {
      // Anyone can create a safety request (even unauthenticated users)
      // This is intentional - victims may not be logged in or may be
      // using someone else's device
      allow create: if true;

      // Only support team members can read safety requests
      // This prevents family members from ever seeing these requests
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['safety-team', 'admin']);

      // Only support team members can update safety requests
      // Updates include: status changes, assignment, admin notes
      allow update: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['safety-team', 'admin']);

      // NEVER allow deletion - compliance requirement
      // Safety requests must be retained for legal/compliance purposes
      allow delete: if false;
    }

    // ============================================
    // ADMIN ROLES COLLECTION
    // ============================================
    // Stores admin/support team role assignments
    // Only readable by the user themselves or other admins

    match /adminRoles/{userId} {
      // Users can read their own role document
      allow read: if request.auth != null && request.auth.uid == userId;

      // Only admins can read other users' roles
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['admin']);

      // Only admins can create/update/delete role assignments
      allow write: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['admin']);
    }

    // ============================================
    // USERS COLLECTION (Story 1.2, updated Story 2.1)
    // ============================================
    // Stores user profile data created on first sign-in
    //
    // Security invariants:
    // 1. Users can only read/write their own profile document
    // 2. uid must match the authenticated user's uid
    // 3. Required fields: uid, email, createdAt, lastLoginAt
    // 4. createdAt cannot be modified after creation
    // 5. familyId and role can only be set during family creation via transaction
    // 6. familyId cannot be changed once set (prevents family hopping)
    // 7. role can only be changed by guardians with full permissions
    // ============================================

    match /users/{userId} {
      // Users can read their own profile
      allow read: if request.auth != null && request.auth.uid == userId;

      // Users can create their own profile document
      // Validates: uid matches, required fields present, types are correct
      // familyId and role must NOT be set during user creation (only via family creation)
      allow create: if request.auth != null &&
        request.auth.uid == userId &&
        request.resource.data.uid == userId &&
        request.resource.data.keys().hasAll(['uid', 'email', 'createdAt', 'lastLoginAt']) &&
        request.resource.data.uid is string &&
        request.resource.data.email is string &&
        request.resource.data.email.matches('^[^@]+@[^@]+\\.[^@]+$') &&
        !('familyId' in request.resource.data) &&
        !('role' in request.resource.data);

      // Users can update their own profile
      // Validates: uid cannot change, createdAt cannot change
      // familyId can only be set ONCE (when null -> value), never changed after
      // role can only be set when familyId is being set for the first time
      allow update: if request.auth != null &&
        request.auth.uid == userId &&
        request.resource.data.uid == resource.data.uid &&
        request.resource.data.createdAt == resource.data.createdAt &&
        // familyId validation: can only be set once, never removed or changed
        (
          // Case 1: familyId unchanged (not in update or same value)
          (!('familyId' in request.resource.data) && !('familyId' in resource.data)) ||
          (request.resource.data.familyId == resource.data.familyId) ||
          // Case 2: familyId being set for first time (null/missing -> value)
          (!('familyId' in resource.data) && 'familyId' in request.resource.data &&
           request.resource.data.familyId is string && request.resource.data.familyId.size() > 0)
        ) &&
        // role validation: can only be set when familyId is being set
        // and must be 'guardian' when creating a family
        (
          // Case 1: role unchanged
          (!('role' in request.resource.data) && !('role' in resource.data)) ||
          (request.resource.data.role == resource.data.role) ||
          // Case 2: role being set for first time (only valid with familyId, must be 'guardian')
          (!('role' in resource.data) && 'role' in request.resource.data &&
           !('familyId' in resource.data) && 'familyId' in request.resource.data &&
           request.resource.data.role == 'guardian')
        );

      // Users cannot delete their own profile
      // Deletion should go through proper account deletion flow
      allow delete: if false;
    }

    // ============================================
    // FAMILIES COLLECTION (Story 2.1)
    // ============================================
    // Stores family documents with guardian and child references
    //
    // Security invariants:
    // 1. Only authenticated users can create families
    // 2. Creator must set themselves as primary guardian
    // 3. Only guardians with 'full' permissions can read/update family
    // 4. Families cannot be deleted (for audit purposes)
    // 5. Guardian array must have valid structure (prevents injection)
    // 6. Maximum 10 guardians per family (prevents abuse)
    // ============================================

    match /families/{familyId} {
      // Helper function to check if user is a guardian in this family
      // Uses explicit index checking to prevent array manipulation attacks
      function isGuardian() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid) ||
            (guardians.size() >= 2 && guardians[1].uid == uid) ||
            (guardians.size() >= 3 && guardians[2].uid == uid) ||
            (guardians.size() >= 4 && guardians[3].uid == uid) ||
            (guardians.size() >= 5 && guardians[4].uid == uid) ||
            (guardians.size() >= 6 && guardians[5].uid == uid) ||
            (guardians.size() >= 7 && guardians[6].uid == uid) ||
            (guardians.size() >= 8 && guardians[7].uid == uid) ||
            (guardians.size() >= 9 && guardians[8].uid == uid) ||
            (guardians.size() >= 10 && guardians[9].uid == uid)
          );
      }

      // Helper function to check if user has full permissions
      // Uses explicit index checking for security
      function hasFullPermissions() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Helper function to validate guardian structure
      function isValidGuardian(guardian) {
        return guardian.keys().hasAll(['uid', 'role', 'permissions', 'joinedAt']) &&
          guardian.uid is string &&
          guardian.uid.size() > 0 &&
          guardian.role in ['primary', 'co-parent'] &&
          guardian.permissions in ['full', 'readonly'];
      }

      // Users can create a family if:
      // - They are authenticated
      // - They set themselves as the creator
      // - They set themselves as the ONLY guardian with 'primary' role
      // - Guardian has valid structure
      // - Children array starts empty
      // NOTE: Exactly 1 guardian on creation prevents bypassing invitation flow
      allow create: if request.auth != null &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() == 1 &&  // Exactly 1 guardian on creation
        request.resource.data.guardians[0].uid == request.auth.uid &&
        request.resource.data.guardians[0].role == 'primary' &&
        request.resource.data.guardians[0].permissions == 'full' &&
        isValidGuardian(request.resource.data.guardians[0]) &&
        request.resource.data.children is list &&
        request.resource.data.children.size() == 0;  // Must start with no children

      // Only guardians can read their family
      allow read: if isGuardian();

      // Only guardians with full permissions can update
      // Additional validation: cannot remove all guardians, cannot exceed 10
      allow update: if hasFullPermissions() &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() >= 1 &&
        request.resource.data.guardians.size() <= 10 &&
        request.resource.data.children is list &&
        // Prevent changing createdBy (immutable)
        request.resource.data.createdBy == resource.data.createdBy &&
        // Prevent changing createdAt (immutable)
        request.resource.data.createdAt == resource.data.createdAt;

      // Families cannot be deleted (for audit purposes)
      allow delete: if false;

      // ============================================
      // FAMILY AUDIT LOG SUBCOLLECTION (Story 2.5)
      // ============================================
      // Stores audit entries for family actions (child updates, guardian changes, etc.)
      //
      // Security invariants:
      // 1. Only guardians can read audit logs
      // 2. Only guardians can create audit entries (via transaction)
      // 3. Audit entries are immutable - no updates or deletes
      // 4. performedBy must match authenticated user
      // ============================================
      match /auditLog/{logId} {
        // Only guardians can read audit logs
        allow read: if isGuardian();

        // Only guardians can create audit entries
        // Validates: performedBy matches authenticated user
        allow create: if isGuardian() &&
          request.resource.data.performedBy == request.auth.uid &&
          request.resource.data.id == logId &&
          request.resource.data.action is string &&
          request.resource.data.entityId is string &&
          request.resource.data.entityType is string;

        // Audit entries are immutable - no updates
        allow update: if false;

        // Audit entries cannot be deleted
        allow delete: if false;
      }
    }

    // ============================================
    // CHILDREN COLLECTION (Story 2.2, Story 2.3, Story 2.5)
    // ============================================
    // Stores child profile documents
    //
    // Security invariants:
    // 1. Only guardians can create children in their family
    // 2. Only guardians with 'full' permissions can read/update children
    // 3. Children cannot be deleted (audit requirement)
    // 4. familyId must match the creator's family
    // 5. Maximum 10 guardians per child (same as family limit)
    // 6. Custody declaration can only be set/updated by guardians with full permissions
    // 7. Custody history can only grow, never shrink (audit trail)
    // 8. custodyDeclaration.type must be 'sole', 'shared', or 'complex'
    //
    // MONITORING GATE (Story 2.3, AC7 - Epic 9/12 enforcement):
    // - Device monitoring CANNOT be started until custody is declared
    // - Client-side check: canStartMonitoring(child) helper in contracts
    // - Server-side enforcement: devices collection rules will verify
    //   custodyDeclaration exists before allowing device enrollment
    // - This ensures custody arrangements are documented before monitoring begins
    // ============================================

    match /children/{childId} {
      // Helper function to check if user is a guardian for this child
      // Uses explicit index checking to prevent array manipulation attacks
      function isChildGuardian() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid) ||
            (guardians.size() >= 2 && guardians[1].uid == uid) ||
            (guardians.size() >= 3 && guardians[2].uid == uid) ||
            (guardians.size() >= 4 && guardians[3].uid == uid) ||
            (guardians.size() >= 5 && guardians[4].uid == uid) ||
            (guardians.size() >= 6 && guardians[5].uid == uid) ||
            (guardians.size() >= 7 && guardians[6].uid == uid) ||
            (guardians.size() >= 8 && guardians[7].uid == uid) ||
            (guardians.size() >= 9 && guardians[8].uid == uid) ||
            (guardians.size() >= 10 && guardians[9].uid == uid)
          );
      }

      // Helper function to check if user has full permissions on child
      // Uses explicit index checking for security
      function hasFullChildPermissions() {
        let guardians = resource.data.guardians;
        let uid = request.auth.uid;
        return request.auth != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid && guardians[0].permissions == 'full') ||
            (guardians.size() >= 2 && guardians[1].uid == uid && guardians[1].permissions == 'full') ||
            (guardians.size() >= 3 && guardians[2].uid == uid && guardians[2].permissions == 'full') ||
            (guardians.size() >= 4 && guardians[3].uid == uid && guardians[3].permissions == 'full') ||
            (guardians.size() >= 5 && guardians[4].uid == uid && guardians[4].permissions == 'full') ||
            (guardians.size() >= 6 && guardians[5].uid == uid && guardians[5].permissions == 'full') ||
            (guardians.size() >= 7 && guardians[6].uid == uid && guardians[6].permissions == 'full') ||
            (guardians.size() >= 8 && guardians[7].uid == uid && guardians[7].permissions == 'full') ||
            (guardians.size() >= 9 && guardians[8].uid == uid && guardians[8].permissions == 'full') ||
            (guardians.size() >= 10 && guardians[9].uid == uid && guardians[9].permissions == 'full')
          );
      }

      // Helper function to check if user is a guardian in the target family
      // CRITICAL: This prevents cross-family child injection attacks
      // Uses explicit index checking for security (same pattern as isGuardian in families)
      function isGuardianInTargetFamily(familyId) {
        let familyDoc = get(/databases/$(database)/documents/families/$(familyId));
        let guardians = familyDoc.data.guardians;
        let uid = request.auth.uid;
        return familyDoc != null &&
          guardians is list &&
          guardians.size() >= 1 &&
          guardians.size() <= 10 &&
          (
            (guardians.size() >= 1 && guardians[0].uid == uid) ||
            (guardians.size() >= 2 && guardians[1].uid == uid) ||
            (guardians.size() >= 3 && guardians[2].uid == uid) ||
            (guardians.size() >= 4 && guardians[3].uid == uid) ||
            (guardians.size() >= 5 && guardians[4].uid == uid) ||
            (guardians.size() >= 6 && guardians[5].uid == uid) ||
            (guardians.size() >= 7 && guardians[6].uid == uid) ||
            (guardians.size() >= 8 && guardians[7].uid == uid) ||
            (guardians.size() >= 9 && guardians[8].uid == uid) ||
            (guardians.size() >= 10 && guardians[9].uid == uid)
          );
      }

      // Users can create children if:
      // - They are authenticated
      // - They set themselves as the creator
      // - They are the only guardian on creation (exactly 1)
      // - They have 'full' permissions on the child
      // - familyId references an existing family
      // - CRITICAL: Creator must be a guardian in that family (prevents cross-family injection)
      // - Required fields are present
      allow create: if request.auth != null &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() == 1 &&
        request.resource.data.guardians[0].uid == request.auth.uid &&
        request.resource.data.guardians[0].permissions == 'full' &&
        request.resource.data.familyId is string &&
        request.resource.data.familyId.size() > 0 &&
        request.resource.data.firstName is string &&
        request.resource.data.firstName.size() >= 1 &&
        request.resource.data.firstName.size() <= 50 &&
        // Verify the family exists AND user is a guardian in that family
        exists(/databases/$(database)/documents/families/$(request.resource.data.familyId)) &&
        isGuardianInTargetFamily(request.resource.data.familyId);

      // Only guardians can read children
      allow read: if isChildGuardian();

      // Only guardians with full permissions can update
      // Cannot change: createdBy, createdAt, familyId (immutable)
      // Custody validation: history can only grow, type must be valid
      allow update: if hasFullChildPermissions() &&
        request.resource.data.createdBy == resource.data.createdBy &&
        request.resource.data.createdAt == resource.data.createdAt &&
        request.resource.data.familyId == resource.data.familyId &&
        request.resource.data.guardians is list &&
        request.resource.data.guardians.size() >= 1 &&
        request.resource.data.guardians.size() <= 10 &&
        // Custody history validation: can only grow, never shrink (audit trail)
        (
          // Case 1: No custody history in either old or new data
          (!('custodyHistory' in resource.data) && !('custodyHistory' in request.resource.data)) ||
          // Case 2: Adding custody history for first time
          (!('custodyHistory' in resource.data) && 'custodyHistory' in request.resource.data &&
           request.resource.data.custodyHistory is list) ||
          // Case 3: Custody history exists and can only grow
          ('custodyHistory' in resource.data && 'custodyHistory' in request.resource.data &&
           request.resource.data.custodyHistory is list &&
           request.resource.data.custodyHistory.size() >= resource.data.custodyHistory.size())
        ) &&
        // Custody declaration type validation: must be 'sole', 'shared', or 'complex'
        (
          // Case 1: No custody declaration
          !('custodyDeclaration' in request.resource.data) ||
          // Case 2: Custody declaration is null (cleared)
          request.resource.data.custodyDeclaration == null ||
          // Case 3: Custody declaration has valid type
          ('custodyDeclaration' in request.resource.data &&
           request.resource.data.custodyDeclaration != null &&
           request.resource.data.custodyDeclaration.type in ['sole', 'shared', 'complex'])
        );

      // Children cannot be deleted (audit requirement)
      allow delete: if false;
    }

    // ============================================
    // DEVICES COLLECTION (Epic 9/12 - Future Implementation)
    // ============================================
    // PLACEHOLDER: Device enrollment and monitoring data
    //
    // CRITICAL SECURITY REQUIREMENT (Story 2.3, AC7):
    // Device enrollment MUST verify that the child has a custody declaration
    // before allowing monitoring to begin. This ensures:
    // 1. Custody arrangements are documented before any monitoring
    // 2. Shared custody families have appropriate safeguards in place
    // 3. Legal/compliance requirements are met for child monitoring
    //
    // Future rules must check:
    // - User is guardian with 'full' permissions on the child
    // - Child document has custodyDeclaration != null
    // - If custodyDeclaration.type == 'shared', Epic 3A safeguards are applied
    //
    // Example rule pattern (to be implemented in Epic 9/12):
    // allow create: if hasFullChildPermissions(childId) &&
    //   get(/databases/$(database)/documents/children/$(childId)).data.custodyDeclaration != null;
    // ============================================

    // match /devices/{deviceId} {
    //   // TODO: Implement in Epic 9/12
    //   allow read, write: if false;
    // }

    // ============================================
    // ADMIN AUDIT LOG COLLECTION
    // ============================================
    // Separate audit log for admin/support actions
    // NEVER linked to family audit trails

    match /adminAuditLog/{logId} {
      // Only admins can read audit logs
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/adminRoles/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/adminRoles/$(request.auth.uid)).data.roles.hasAny(['admin']);

      // System can write audit entries (via Cloud Functions)
      // Direct client writes are not allowed
      allow write: if false;
    }
  }
}
